<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="copyright" title="版权所有" href="../copyright.html" /><link rel="next" title="使用 UPDATE 和 DELETE 语句" href="data_update.html" /><link rel="prev" title="使用 INSERT 语句" href="data_insert.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.08.06 -->
        <title>使用 SELECT 语句 - SQLAlchemy 2.1 Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/changelog.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_paramlinks.css" />
    <link rel="stylesheet" type="text/css" href="../_static/docs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">SQLAlchemy 2.1 Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">SQLAlchemy 2.1 Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">概述</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">SQLAlchemy 统一教程</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of SQLAlchemy 统一教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="engine.html">建立连接 - Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="dbapi_transactions.html">使用事务和DBAPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="metadata.html">使用数据库元数据</a></li>
<li class="toctree-l2 current has-children"><a class="reference internal" href="data.html">处理数据</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of 处理数据</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="data_insert.html">使用 INSERT 语句</a></li>
<li class="toctree-l3 current current-page"><a class="current reference internal" href="#">使用 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_update.html">使用 UPDATE 和 DELETE 语句</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="orm_data_manipulation.html">使用 ORM 进行数据操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="orm_related_objects.html">使用 ORM 相关对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="further_reading.html">进一步阅读</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../orm/index.html">SQLAlchemy ORM</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of SQLAlchemy ORM</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../orm/quickstart.html">ORM 快速入门</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/mapper_config.html">ORM 映射类配置</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of ORM 映射类配置</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapping_styles.html">ORM 映射类概述</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../orm/declarative_mapping.html">使用声明式映射类</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 使用声明式映射类</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_styles.html">声明式映射风格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_tables.html">声明式的表配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_config.html">使用声明式映射器配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_mixins.html">使用 Mixins 组合映射层次结构</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../orm/dataclasses.html">与dataclass和attrs的集成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapped_sql_expr.html">SQL 表达式作为映射属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapped_attributes.html">更改Attribute的行为</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/composites.html">复合列类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/inheritance.html">映射类继承层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/nonstandard_mappings.html">非传统映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/versioning.html">配置版本计数器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapping_api.html">类映射 API</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../orm/scalar_mapping.html">映射 SQL 表达式</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 映射 SQL 表达式</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../orm/mapping_columns.html">映射表格列</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/relationships.html">关系配置</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of 关系配置</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/basic_relationships.html">基本关系模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/self_referential.html">邻接表关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/join_conditions.html">配置关系连接方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/large_collections.html">使用大型集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/collection_api.html">集合自定义和 API 详细信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/relationship_persistence.html">特殊关系的持久化模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/backref.html">使用旧版“backref”关系参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/relationship_api.html">关系 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/queryguide/index.html">ORM 查询指南</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of ORM 查询指南</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/select.html">为 ORM 映射类编写 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/inheritance.html">为继承映射编写 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/dml.html">启用 ORM 的 INSERT、UPDATE 和 DELETE 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/columns.html">列加载选项</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/relationships.html">关系加载技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/api.html">用于查询的 ORM API 功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/query.html">旧式查询 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/session.html">使用会话</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 使用会话</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_basics.html">会话基础知识</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_state_management.html">状态管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/cascades.html">级联</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_transaction.html">事务和连接管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/persistence_techniques.html">附加持久性技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/contextual.html">上下文/线程本地会话</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_events.html">使用事件跟踪查询、对象和会话更改</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_api.html">会话 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/extending.html">事件和内部</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of 事件和内部</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/events.html">ORM 事件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/internals.html">ORM 内部</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/exceptions.html">ORM 异常</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/extensions/index.html">ORM 扩展</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of ORM 扩展</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/asyncio.html">异步 I/O (asyncio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/associationproxy.html">关联代理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/automap.html">自动映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/baked.html">烘焙查询</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/declarative/index.html">声明式扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/mutable.html">突变追踪</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/orderinglist.html">排序列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/horizontal_shard.html">水平分片</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/hybrid.html">混合属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/indexable.html">Indexable</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/instrumentation.html">替代类检测</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../orm/examples.html">核心和 ORM 示例</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../core/index.html">SQLAlchemy Core</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of SQLAlchemy Core</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/expression_api.html">SQL 语句和表达式 API</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of SQL 语句和表达式 API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/sqlelement.html">列元素和表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/operators.html">操作符参考</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/selectable.html">SELECT 和相关构造</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/dml.html">插入,更新,删除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/functions.html">SQL 和 范型函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/compiler.html">自定义 SQL 构造和编译扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/serializer.html">表达式序列化器扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/foundation.html">SQL 表达式语言基础构造</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/visitors.html">访问者和遍历实用程序</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/schema.html">Schema 定义语言</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of Schema 定义语言</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/metadata.html">使用元数据描述数据库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/reflection.html">反映数据库对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/defaults.html">列 INSERT/UPDATE 默认值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/constraints.html">定义约束和索引</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/ddl.html">自定义 DDL</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/types.html">SQL 数据类型对象</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of SQL 数据类型对象</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/type_basics.html">类型层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/custom_types.html">自定义类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/type_api.html">基本类型 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/engines_connections.html">Engine和Connection的使用</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle navigation of Engine和Connection的使用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/engines.html">Engine 配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/connections.html">使用Engines和Connection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/pooling.html">连接池</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/events.html">核心事件</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/api_basics.html">Core API 基础</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle navigation of Core API 基础</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/event.html">事件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/inspection.html">运行时审查 API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/exceptions.html">Core 异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/internals.html">Core 内部</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../dialects/index.html">Dialects</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle navigation of Dialects</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../dialects/postgresql.html">PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/mysql.html">MySQL 和 MariaDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/sqlite.html">SQLite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/oracle.html">Oracle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/mssql.html">Microsoft SQL Server</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../faq/index.html">常见问题</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle navigation of 常见问题</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/installation.html">安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/connections.html">连接 / 引擎</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/metadata_schema.html">元数据 / Schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/sqlexpressions.html">SQL 表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/ormconfiguration.html">ORM 配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/performance.html">性能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/sessions.html">会话 / 查询</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/thirdparty.html">第三方包集成问题</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">错误消息</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../changelog/index.html">变更和迁移</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle navigation of 变更和迁移</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_21.html">SQLAlchemy 2.1 有什么新功能？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_21.html">2.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_20.html">2.0 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_14.html">1.4 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_13.html">1.3 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_12.html">1.2 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_11.html">1.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_10.html">1.0 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_09.html">0.9 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_08.html">0.8 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_07.html">0.7 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_06.html">0.6 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_05.html">0.5 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_04.html">0.4 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_03.html">0.3 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_02.html">0.2 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_01.html">0.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_20.html">SQLAlchemy 2.0 - Major Migration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/whatsnew_20.html">What’s New in SQLAlchemy 2.0?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_14.html">What’s New in SQLAlchemy 1.4?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_13.html">What’s New in SQLAlchemy 1.3?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_12.html">What’s New in SQLAlchemy 1.2?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_11.html">What’s New in SQLAlchemy 1.1?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_10.html">What’s New in SQLAlchemy 1.0?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_09.html">What’s New in SQLAlchemy 0.9?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_08.html">What’s New in SQLAlchemy 0.8?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_07.html">What’s New in SQLAlchemy 0.7?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_06.html">What’s New in SQLAlchemy 0.6?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_05.html">What’s new in SQLAlchemy 0.5?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_04.html">What’s new in SQLAlchemy 0.4?</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          

<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>This page is part of the <a class="reference internal" href="index.html"><span class="doc">SQLAlchemy 统一教程</span></a>.</p>
<p>Previous: <a class="reference internal" href="data_insert.html"><span class="doc">使用 INSERT 语句</span></a>   |   Next: <a class="reference internal" href="data_update.html"><span class="doc">使用 UPDATE 和 DELETE 语句</span></a></p>
</aside>
<section class="core-header orm-dependency" id="select">
<span id="tutorial-selecting-data"></span><h1>使用 SELECT 语句<a class="headerlink" href="#select" title="Link to this heading">¶</a></h1>
<p>Using SELECT Statements</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>对于 Core 和 ORM，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 函数生成一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造，用于所有 SELECT 查询。
在 Core 中传递给 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a> 方法，在 ORM 中传递给 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> 方法，在当前事务中发出一个 SELECT 语句，并通过返回的 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> 对象获取结果行。</p>
<div class="orm-header docutils container">
<p><strong>ORM 读者</strong> - 这里的内容同样适用于 Core 和 ORM 的使用，并且提到了基本的 ORM 变体用例。然而，还有更多特定于 ORM 的功能；这些记录在 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a>。</p>
</div>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>For both Core and ORM, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> function generates a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct which is used for all SELECT queries.
Passed to methods like <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a> in Core and
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> in ORM, a SELECT statement is emitted in the
current transaction and the result rows available via the returned
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Result" title="sqlalchemy.engine.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> object.</p>
<div class="orm-header docutils container">
<p><strong>ORM Readers</strong> - the content here applies equally well to both Core and ORM
use and basic ORM variant use cases are mentioned here.  However there are
a lot more ORM-specific features available as well; these are documented
at <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a>.</p>
</div>
</div>
</div>
<section id="select-sql">
<h2>select() SQL 表达式构造<a class="headerlink" href="#select-sql" title="Link to this heading">¶</a></h2>
<p>The select() SQL Expression Construct</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造的语句构建方式与 <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a> 类似，使用 <a class="reference internal" href="../glossary.html#term-generative"><span class="xref std std-term">generative</span></a> 方法，其中每个方法在对象上构建更多状态。与其他 SQL 构造一样，它可以直接字符串化:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span>
</div></pre></div>
</div>
<p>与所有其他语句级 SQL 构造相同，要实际运行该语句，我们将其传递给执行方法。由于 SELECT 语句返回行，我们始终可以迭代结果对象以获取 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(1, &#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>使用 ORM 时，特别是对于针对 ORM 实体构建的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，我们需要使用 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 上的 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> 方法来执行它；使用这种方法，我们继续从结果中获取 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象，但是这些行现在能够包括完整的实体，例如 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类的实例，作为每行中的单个元素：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for row in session.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>以下部分将更详细地讨论 SELECT 构造。</p>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct builds up a statement in the same way
as that of <a class="reference internal" href="../core/dml.html#sqlalchemy.sql.expression.insert" title="sqlalchemy.sql.expression.insert"><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></a>, using a <a class="reference internal" href="../glossary.html#term-generative"><span class="xref std std-term">generative</span></a> approach where
each method builds more state onto the object.  Like the other SQL constructs,
it can be stringified in place:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">select</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span>
</div></pre></div>
</div>
<p>Also in the same manner as all other statement-level SQL constructs, to
actually run the statement we pass it to an execution method.
Since a SELECT statement returns
rows we can always iterate the result object to get <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a>
objects back:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(1, &#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>When using the ORM, particularly with a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct that’s
composed against ORM entities, we will want to execute it using the
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> method on the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>; using
this approach, we continue to get <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> objects from the
result, however these rows are now capable of including
complete entities, such as instances of the <code class="docutils literal notranslate"><span class="pre">User</span></code> class, as individual
elements within each row:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for row in session.execute(stmt):</span>
<span class="go">...         print(row)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;spongebob&#39;</span><span class="p">,)</span>
</div><span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>The following sections will discuss the SELECT construct in more detail.</p>
</div>
</div>
</section>
<section id="columns-from">
<span id="tutorial-selecting-columns"></span><h2>设置 COLUMNS 和 FROM 子句<a class="headerlink" href="#columns-from" title="Link to this heading">¶</a></h2>
<p>Setting the COLUMNS and FROM clause</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 函数接受表示任意数量的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 和/或 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 表达式的位置元素，以及广泛的兼容对象，这些对象被解析为要从中 SELECT 的 SQL 表达式列表，这些表达式将作为结果集中返回的列。这些元素在更简单的情况下也用于创建 FROM 子句，该子句是从传递的列和类似表的表达式推断出来的:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>要使用 Core 方法从单个列 SELECT，<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象从 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.c" title="sqlalchemy.schema.Table.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code></a> 访问器访问并可以直接发送；FROM 子句将被推断为那些列所代表的所有 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 和其他 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> 对象的集合:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>或者，当使用任何 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> （如 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>）的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> 集合时，可以通过使用字符串名称的元组为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 指定多个列:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">]))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 2.0 版本加入: </span>为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> 集合添加了元组访问器功能</p>
</div>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> function accepts positional elements representing any
number of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> and/or <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> expressions, as
well as a wide range of compatible objects, which are resolved into a list of SQL
expressions to be SELECTed from that will be returned as columns in the result
set.  These elements also serve in simpler cases to create the FROM clause,
which is inferred from the columns and table-like expressions passed:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>To SELECT from individual columns using a Core approach,
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects are accessed from the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.c" title="sqlalchemy.schema.Table.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code></a>
accessor and can be sent directly; the FROM clause will be inferred as the set
of all <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> and other <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> objects that
are represented by those columns:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>Alternatively, when using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> collection of any
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> such as <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, multiple columns may be specified
for a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> by using a tuple of string names:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;fullname&quot;</span><span class="p">]))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">在 2.0 版本加入: </span>Added tuple-accessor capability to the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> collection</p>
</div>
</div>
</div>
<section id="orm">
<span id="tutorial-selecting-orm-entities"></span><h3>选择 ORM 实体和列<a class="headerlink" href="#orm" title="Link to this heading">¶</a></h3>
<p>Selecting ORM Entities and Columns</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>ORM 实体，如我们的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类以及它上面映射到列的属性如 <code class="docutils literal notranslate"><span class="pre">User.name</span></code>，也参与表示表和列的 SQL 表达式语言系统。下面展示了一个从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体中 SELECT 的示例，最终呈现的方式与我们直接使用 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 一样：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span>
<span class="go">{printsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<p>当使用 ORM <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> 方法执行如上语句时，与从 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 中 SELECT 相比，有一个重要的区别，即 <strong>实体本身作为每行中的单个元素返回</strong>。也就是说，当我们从上述语句中获取行时，由于要获取的内容列表中只有 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体，我们返回的 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 对象只有一个元素，其中包含 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类的实例：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}BEGIN...</span>
<span class="go">SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">[...] (){stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span></pre></div>
</div>
<p>上述 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> 只有一个元素，表示 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>一种强烈推荐的实现上述相同结果的便捷方法是直接使用 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.scalars" title="sqlalchemy.orm.Session.scalars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.scalars()</span></code></a> 方法执行语句；该方法将返回一个 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ScalarResult" title="sqlalchemy.engine.ScalarResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarResult</span></code></a> 对象，该对象一次提供每行的第一个“列”，在这种情况下，是 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类的实例：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.id, user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">[...] (){stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>或者，我们可以选择 ORM 实体的单个列作为结果行中的独立元素，通过使用类绑定的属性；当这些属性传递给诸如 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 之类的构造时，它们将解析为每个属性表示的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 或其他 SQL 表达式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<span class="go">{printsql}SELECT user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span></pre></div>
</div>
<p>当我们使用 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> 调用*这个*语句时，我们现在收到的行对于每个值都有单独的元素，每个元素对应一个单独的列或其他 SQL 表达式：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.name, user_account.fullname</span>
<span class="go">FROM user_account</span>
<span class="go">[...] (){stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(&#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>这些方法也可以混合使用，如下所示，我们将 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体的 <code class="docutils literal notranslate"><span class="pre">name</span></code> 属性作为行的第一个元素，并将完整的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 实体作为第二个元素：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Address</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.name, address.id, address.email_address, address.user_id</span>
<span class="go">FROM user_account, address</span>
<span class="go">WHERE user_account.id = address.user_id ORDER BY address.id</span>
<span class="go">[...] (){stop}</span>
<span class="go">[(&#39;spongebob&#39;, Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;))]</span></pre></div>
</div>
<p>选择 ORM 实体和列的方法以及将行转换为常见方法将在 <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择 ORM 实体和属性</span></a> 中进一步讨论。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择 ORM 实体和属性</span></a> - 在 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中</p>
</div>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>ORM entities, such our <code class="docutils literal notranslate"><span class="pre">User</span></code> class as well as the column-mapped
attributes upon it such as <code class="docutils literal notranslate"><span class="pre">User.name</span></code>, also participate in the SQL Expression
Language system representing tables and columns.    Below illustrates an
example of SELECTing from the <code class="docutils literal notranslate"><span class="pre">User</span></code> entity, which ultimately renders
in the same way as if we had used <code class="docutils literal notranslate"><span class="pre">user_table</span></code> directly:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>When executing a statement like the above using the ORM <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>
method, there is an important difference when we select from a full entity
such as <code class="docutils literal notranslate"><span class="pre">User</span></code>, as opposed to <code class="docutils literal notranslate"><span class="pre">user_table</span></code>, which is that the <strong>entity
itself is returned as a single element within each row</strong>.  That is, when we fetch rows from
the above statement, as there is only the <code class="docutils literal notranslate"><span class="pre">User</span></code> entity in the list of
things to fetch, we get back <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> objects that have only one element, which contain
instances of the <code class="docutils literal notranslate"><span class="pre">User</span></code> class:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="p">...</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;),)</span></pre></div>
</div>
<p>The above <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Row" title="sqlalchemy.engine.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code></a> has just one element, representing the <code class="docutils literal notranslate"><span class="pre">User</span></code> entity:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>A highly recommended convenience method of achieving the same result as above
is to use the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.scalars" title="sqlalchemy.orm.Session.scalars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.scalars()</span></code></a> method to execute the statement
directly; this method will return a <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.ScalarResult" title="sqlalchemy.engine.ScalarResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarResult</span></code></a> object
that delivers the first “column” of each row at once, in this case,
instances of the <code class="docutils literal notranslate"><span class="pre">User</span></code> class:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">scalars</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">user</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>Alternatively, we can select individual columns of an ORM entity as distinct
elements within result rows, by using the class-bound attributes; when these
are passed to a construct such as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>, they are resolved into
the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> or other SQL expression represented by each
attribute:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>When we invoke <em>this</em> statement using <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>, we now
receive rows that have individual elements per value, each corresponding
to a separate column or other SQL expression:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">row</span>
<span class="go">(&#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)</span></pre></div>
</div>
<p>The approaches can also be mixed, as below where we SELECT the <code class="docutils literal notranslate"><span class="pre">name</span></code>
attribute of the <code class="docutils literal notranslate"><span class="pre">User</span></code> entity as the first element of the row, and combine
it with full <code class="docutils literal notranslate"><span class="pre">Address</span></code> entities in the second element:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="go">...     select(User.name, Address).where(User.id == Address.user_id).order_by(Address.id)</span>
<span class="go">... ).all()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;spongebob&#39;, Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)),</span>
<span class="go">(&#39;sandy&#39;, Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;))]</span></pre></div>
</div>
<p>Approaches towards selecting ORM entities and columns as well as common methods
for converting rows are discussed further at <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择 ORM 实体和属性</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-columns"><span class="std std-ref">选择 ORM 实体和属性</span></a> - in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
</div>
</section>
<section id="sql">
<h3>从带标签的 SQL 表达式中选择<a class="headerlink" href="#sql" title="Link to this heading">¶</a></h3>
<p>Selecting from Labeled SQL Expressions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.label()</span></code></a> 方法以及 ORM 属性上相同名称的方法提供了列或表达式的 SQL 标签，使其在结果集中具有特定名称。这在按名称引用结果行中的任意 SQL 表达式时非常有用：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="go">...     (&quot;Username: &quot; + user_table.c.name).label(&quot;username&quot;),</span>
<span class="go">... ).order_by(user_table.c.name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(f&quot;{row.username}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">username</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Username: &#39;</span><span class="p">,)</span>
</div><span class="go">Username: patrick</span>
<span class="go">Username: sandy</span>
<span class="go">Username: spongebob</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#tutorial-order-by-label"><span class="std std-ref">按标签排序或分组</span></a> - 我们创建的标签名称也可以在 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 的 ORDER BY 或 GROUP BY 子句中引用。</p>
</div>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label" title="sqlalchemy.sql.expression.ColumnElement.label"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.label()</span></code></a> method as well as the same-named method
available on ORM attributes provides a SQL label of a column or expression,
allowing it to have a specific name in a result set.  This can be helpful
when referring to arbitrary SQL expressions in a result row by name:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span>
<span class="go">...     (&quot;Username: &quot; + user_table.c.name).label(&quot;username&quot;),</span>
<span class="go">... ).order_by(user_table.c.name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     for row in conn.execute(stmt):</span>
<span class="go">...         print(f&quot;{row.username}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">username</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Username: &#39;</span><span class="p">,)</span>
</div><span class="go">Username: patrick</span>
<span class="go">Username: sandy</span>
<span class="go">Username: spongebob</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="#tutorial-order-by-label"><span class="std std-ref">按标签排序或分组</span></a> - the label names we create may also be
referenced in the ORDER BY or GROUP BY clause of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>.</p>
</div>
</div>
</div>
</section>
<section id="tutorial-select-arbitrary-text">
<span id="id1"></span><h3>使用文本列表达式进行选择<a class="headerlink" href="#tutorial-select-arbitrary-text" title="Link to this heading">¶</a></h3>
<p>Selecting with Textual Column Expressions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>当我们使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 函数构造 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 对象时，通常会传递一系列使用 <a class="reference internal" href="metadata.html#tutorial-working-with-metadata"><span class="std std-ref">table metadata</span></a> 定义的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 和 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象，或者在使用 ORM 时，我们可能会发送表示表列的 ORM 映射属性。然而，有时也需要在语句中制造任意 SQL 块，例如常量字符串表达式，或者只是一些更快地直接编写的任意 SQL。</p>
<p>在 <a class="reference internal" href="dbapi_transactions.html#tutorial-working-with-transactions"><span class="std std-ref">使用事务和DBAPI</span></a> 中介绍的 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 构造实际上可以直接嵌入到 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造中，例如下面我们制造一个硬编码字符串字面量 <code class="docutils literal notranslate"><span class="pre">'some</span> <span class="pre">phrase'</span></code> 并将其嵌入到 SELECT 语句中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span></pre></div>
</div>
<p>…     print(conn.execute(stmt).all())
{execsql}BEGIN (implicit)
SELECT ‘some phrase’, user_account.name
FROM user_account ORDER BY user_account.name
[generated in …] ()
{stop}[(‘some phrase’, ‘patrick’), (‘some phrase’, ‘sandy’), (‘some phrase’, ‘spongebob’)]
{execsql}ROLLBACK{stop}</p>
<p>虽然 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 构造可以在大多数地方用于注入字面 SQL 短语，但更多时候我们实际上在处理每个表示单个列表达式的文本单元。在这种常见情况下，我们可以使用 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a> 构造从我们的文本片段中获得更多功能。此对象类似于 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a>，但它明确表示单个“列”，然后可以在子查询和其他表达式中标记和引用:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">literal_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span></pre></div>
</div>
<p>…     user_table.c.name
… )
&gt;&gt;&gt; with engine.connect() as conn:
…     for row in conn.execute(stmt):
…         print(f”{row.p}, {row.name}”)
{execsql}BEGIN (implicit)
SELECT ‘some phrase’ AS p, user_account.name
FROM user_account ORDER BY user_account.name
[generated in …] ()
{stop}some phrase, patrick
some phrase, sandy
some phrase, spongebob
{execsql}ROLLBACK{stop}</p>
<p>请注意，在两种情况下，当使用 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> 或 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a> 时，我们正在编写一个语法 SQL 表达式，而不是一个字面值。因此，我们必须包括所需的任何引用或语法以呈现我们希望看到的 SQL。</p>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>When we construct a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> object using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>
function, we are normally passing to it a series of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
and <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects that were defined using
<a class="reference internal" href="metadata.html#tutorial-working-with-metadata"><span class="std std-ref">table metadata</span></a>, or when using the ORM we may be
sending ORM-mapped attributes that represent table columns.   However,
sometimes there is also the need to manufacture arbitrary SQL blocks inside
of statements, such as constant string expressions, or just some arbitrary
SQL that’s quicker to write literally.</p>
<p>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> construct introduced at
<a class="reference internal" href="dbapi_transactions.html#tutorial-working-with-transactions"><span class="std std-ref">使用事务和DBAPI</span></a> can in fact be embedded into a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct directly, such as below where we manufacture
a hardcoded string literal <code class="docutils literal notranslate"><span class="pre">'some</span> <span class="pre">phrase'</span></code> and embed it within the
SELECT statement:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">text</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span></pre></div>
</div>
<p>…     print(conn.execute(stmt).all())
{execsql}BEGIN (implicit)
SELECT ‘some phrase’, user_account.name
FROM user_account ORDER BY user_account.name
[generated in …] ()
{stop}[(‘some phrase’, ‘patrick’), (‘some phrase’, ‘sandy’), (‘some phrase’, ‘spongebob’)]
{execsql}ROLLBACK{stop}</p>
<p>While the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> construct can be used in most places to inject
literal SQL phrases, more often than not we are actually dealing with textual
units that each represent an individual
column expression.  In this common case we can get more functionality out of
our textual fragment using the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a>
construct instead.  This object is similar to <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> except that
instead of representing arbitrary SQL of any form,
it explicitly represents a single “column” and can then be labeled and referred
towards in subqueries and other expressions:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">literal_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">literal_column</span><span class="p">(</span><span class="s2">&quot;&#39;some phrase&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">),</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span></pre></div>
</div>
<p>…     user_table.c.name
… )
&gt;&gt;&gt; with engine.connect() as conn:
…     for row in conn.execute(stmt):
…         print(f”{row.p}, {row.name}”)
{execsql}BEGIN (implicit)
SELECT ‘some phrase’ AS p, user_account.name
FROM user_account ORDER BY user_account.name
[generated in …] ()
{stop}some phrase, patrick
some phrase, sandy
some phrase, spongebob
{execsql}ROLLBACK{stop}</p>
<p>Note that in both cases, when using <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.text" title="sqlalchemy.sql.expression.text"><code class="xref py py-func docutils literal notranslate"><span class="pre">text()</span></code></a> or
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.literal_column" title="sqlalchemy.sql.expression.literal_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_column()</span></code></a>, we are writing a syntactical SQL expression, and
not a literal value. We therefore have to include whatever quoting or syntaxes
are necessary for the SQL we want to see rendered.</p>
</div>
</div>
</section>
</section>
<section id="where">
<span id="tutorial-select-where-clause"></span><h2>WHERE 子句<a class="headerlink" href="#where" title="Link to this heading">¶</a></h2>
<p>The WHERE clause</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p>SQLAlchemy 允许我们通过使用标准的 Python 运算符与 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 和类似对象结合来组合 SQL 表达式，例如 <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">'squidward'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">user_id</span> <span class="pre">&gt;</span> <span class="pre">10</span></code> 。对于布尔表达式，大多数 Python 运算符如 <code class="docutils literal notranslate"><span class="pre">==</span></code>、 <code class="docutils literal notranslate"><span class="pre">!=</span></code>、 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>、 <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 等生成新的 SQL 表达式对象，而不是普通的布尔 <code class="docutils literal notranslate"><span class="pre">True</span></code> / <code class="docutils literal notranslate"><span class="pre">False</span></code> 值:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">)</span>
<span class="go">user_account.name = :name_1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">address.user_id &gt; :user_id_1</span></pre></div>
</div>
<p>我们可以使用这些表达式通过将结果对象传递给 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> 方法来生成 WHERE 子句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span>
</div></pre></div>
</div>
<p>要生成由 AND 连接的多个表达式，可以多次调用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> 方法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address)</span>
<span class="go">...     .where(user_table.c.name == &quot;squidward&quot;)</span>
<span class="go">...     .where(address_table.c.user_id == user_table.c.id)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>对 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> 的单次调用也接受多个表达式，效果相同:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address).where(</span>
<span class="go">...         user_table.c.name == &quot;squidward&quot;,</span>
<span class="go">...         address_table.c.user_id == user_table.c.id,</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>“AND” 和 “OR” 连接可以直接使用 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a> 和 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a> 函数，如下所示，以 ORM 实体为例:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(Address.email_address).where(</span>
<span class="go">...         and_(</span>
<span class="go">...             or_(User.name == &quot;squidward&quot;, User.name == &quot;sandy&quot;),</span>
<span class="go">...             Address.user_id == User.id,</span>
<span class="go">...         )</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_2</span><span class="p">)</span>
<span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>对于针对单个实体的简单“相等”比较，还有一种流行的方法称为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by" title="sqlalchemy.sql.expression.Select.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.filter_by()</span></code></a>，它接受与列键或 ORM 属性名称匹配的关键字参数。它将过滤最左侧的 FROM 子句或最后一个连接的实体:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">fullname_1</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/operators.html"><span class="doc">操作符参考</span></a> - SQLAlchemy 中大多数 SQL 运算符函数的描述</p>
</div>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p>SQLAlchemy allows us to compose SQL expressions, such as <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">'squidward'</span></code>
or <code class="docutils literal notranslate"><span class="pre">user_id</span> <span class="pre">&gt;</span> <span class="pre">10</span></code>, by making use of standard Python operators in
conjunction with
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> and similar objects.   For boolean expressions, most
Python operators such as <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> etc. generate new
SQL Expression objects, rather than plain boolean <code class="docutils literal notranslate"><span class="pre">True</span></code>/<code class="docutils literal notranslate"><span class="pre">False</span></code> values:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">)</span>
<span class="go">user_account.name = :name_1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">address.user_id &gt; :user_id_1</span></pre></div>
</div>
<p>We can use expressions like these to generate the WHERE clause by passing
the resulting objects to the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;squidward&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span>
</div></pre></div>
</div>
<p>To produce multiple expressions joined by AND, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a>
method may be invoked any number of times:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address)</span>
<span class="go">...     .where(user_table.c.name == &quot;squidward&quot;)</span>
<span class="go">...     .where(address_table.c.user_id == user_table.c.id)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>A single call to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.where" title="sqlalchemy.sql.expression.Select.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.where()</span></code></a> also accepts multiple expressions
with the same effect:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address).where(</span>
<span class="go">...         user_table.c.name == &quot;squidward&quot;,</span>
<span class="go">...         address_table.c.user_id == user_table.c.id,</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>“AND” and “OR” conjunctions are both available directly using the
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.and_" title="sqlalchemy.sql.expression.and_"><code class="xref py py-func docutils literal notranslate"><span class="pre">and_()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.or_" title="sqlalchemy.sql.expression.or_"><code class="xref py py-func docutils literal notranslate"><span class="pre">or_()</span></code></a> functions, illustrated below in terms
of ORM entities:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(Address.email_address).where(</span>
<span class="go">...         and_(</span>
<span class="go">...             or_(User.name == &quot;squidward&quot;, User.name == &quot;sandy&quot;),</span>
<span class="go">...             Address.user_id == User.id,</span>
<span class="go">...         )</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_2</span><span class="p">)</span>
<span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<p>For simple “equality” comparisons against a single entity, there’s also a
popular method known as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by" title="sqlalchemy.sql.expression.Select.filter_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.filter_by()</span></code></a> which accepts keyword
arguments that match to column keys or ORM attribute names.  It will filter
against the leftmost FROM clause or the last entity joined:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">filter_by</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;spongebob&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Spongebob Squarepants&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">fullname_1</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/operators.html"><span class="doc">操作符参考</span></a> - descriptions of most SQL operator functions in SQLAlchemy</p>
</div>
</div>
</div>
</section>
<section id="from-join">
<span id="tutorial-select-join"></span><h2>显式 FROM 子句和 JOIN<a class="headerlink" href="#from-join" title="Link to this heading">¶</a></h2>
<p>Explicit FROM clauses and JOINs</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>正如前面提到的，FROM 子句通常是根据我们在列子句中设置的表达式以及 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 的其他元素推断出来的。</p>
<p>如果我们在 COLUMNS 子句中设置了某个 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 的单列，它也会将该 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 放入 FROM 子句中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>如果我们将两个表的列放在一起，那么我们会得到一个逗号分隔的 FROM 子句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>
</div></pre></div>
</div>
<p>为了将这两个表连接在一起，我们通常使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 上的两种方法之一。第一种是 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 方法，它允许我们明确表示 JOIN 的左侧和右侧:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(user_table.c.name, address_table.c.email_address).join_from(</span>
<span class="go">...         user_table, address_table</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>另一种是 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 方法，它只表示 JOIN 的右侧，左侧是推断出来的:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>我们也可以选择显式地将元素添加到 FROM 子句中，如果它不是我们希望从列子句中推断出来的那样。我们使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> 方法来实现这一点，如下所示，我们将 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 作为 FROM 子句中的第一个元素，并使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 将 <code class="docutils literal notranslate"><span class="pre">address_table</span></code> 作为第二个元素:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>另一个我们可能希望使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> 的示例是，如果我们的列子句没有足够的信息来提供 FROM 子句。例如，要从常见的 SQL 表达式 <code class="docutils literal notranslate"><span class="pre">count(*)</span></code> 中 SELECT，我们使用一个称为 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.func</span></code></a> 的 SQLAlchemy 元素来生成 SQL <code class="docutils literal notranslate"><span class="pre">count()</span></code> 函数:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(:</span><span class="n">count_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-from"><span class="std std-ref">设置连接中最左边的 FROM 子句</span></a> - 在 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中 -
包含更多示例和注释，讨论 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> 和
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 的交互。</p>
</div>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>As mentioned previously, the FROM clause is usually <strong>inferred</strong>
based on the expressions that we are setting in the columns
clause as well as other elements of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>.</p>
<p>If we set a single column from a particular <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
in the COLUMNS clause, it puts that <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> in the FROM
clause as well:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>If we were to put columns from two tables, then we get a comma-separated FROM
clause:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="p">,</span><span class="w"> </span><span class="n">address</span>
</div></pre></div>
</div>
<p>In order to JOIN these two tables together, we typically use one of two methods
on <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>.  The first is the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>
method, which allows us to indicate the left and right side of the JOIN
explicitly:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(user_table.c.name, address_table.c.email_address).join_from(</span>
<span class="go">...         user_table, address_table</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>The other is the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> method, which indicates only the
right side of the JOIN, the left hand-side is inferred:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>We also have the option to add elements to the FROM clause explicitly, if it is not
inferred the way we want from the columns clause.  We use the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> method to achieve this, as below
where we establish <code class="docutils literal notranslate"><span class="pre">user_table</span></code> as the first element in the FROM
clause and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> to establish <code class="docutils literal notranslate"><span class="pre">address_table</span></code> as
the second:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>Another example where we might want to use <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a>
is if our columns clause doesn’t have enough information to provide for a
FROM clause.  For example, to SELECT from the common SQL expression
<code class="docutils literal notranslate"><span class="pre">count(*)</span></code>, we use a SQLAlchemy element known as <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sqlalchemy.sql.expression.func</span></code></a> to
produce the SQL <code class="docutils literal notranslate"><span class="pre">count()</span></code> function:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(:</span><span class="n">count_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-select-from"><span class="std std-ref">设置连接中最左边的 FROM 子句</span></a> - in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> -
contains additional examples and notes
regarding the interaction of <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.select_from" title="sqlalchemy.sql.expression.Select.select_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.select_from()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>.</p>
</div>
</div>
</div>
<section id="on">
<span id="tutorial-select-join-onclause"></span><h3>设置 ON 子句<a class="headerlink" href="#on" title="Link to this heading">¶</a></h3>
<p>Setting the ON Clause</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>前面的 JOIN 示例说明了 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造可以在两个表之间进行连接并自动生成 ON 子句。这些示例中发生这种情况是因为 <code class="docutils literal notranslate"><span class="pre">user_table</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address_table</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code> 对象包含一个用于形成此 ON 子句的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 定义。</p>
<p>如果连接的左右目标没有这样的约束，或者存在多个约束，我们需要直接指定 ON 子句。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 都接受一个附加参数用于 ON 子句，该子句使用与 <a class="reference internal" href="#tutorial-select-where-clause"><span class="std std-ref">WHERE 子句</span></a> 中相同的 SQL 表达机制来声明:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address)</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table, user_table.c.id == address_table.c.user_id)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<div class="orm-header docutils container">
<p><strong>ORM 提示</strong> - 使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造的 ORM 实体时，还有另一种生成 ON 子句的方法，例如在上一节 <a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a> 中设置的映射。
这是一个完整的话题，在 <a class="reference internal" href="orm_related_objects.html#tutorial-joining-relationships"><span class="std std-ref">使用关系进行连接</span></a> 中有详细介绍。</p>
</div>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>The previous examples of JOIN illustrated that the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct
can join between two tables and produce the ON clause automatically.  This
occurs in those examples because the <code class="docutils literal notranslate"><span class="pre">user_table</span></code> and <code class="docutils literal notranslate"><span class="pre">address_table</span></code>
<code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code> objects include a single <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
definition which is used to form this ON clause.</p>
<p>If the left and right targets of the join do not have such a constraint, or
there are multiple constraints in place, we need to specify the ON clause
directly.   Both <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>
accept an additional argument for the ON clause, which is stated using the
same SQL Expression mechanics as we saw about in <a class="reference internal" href="#tutorial-select-where-clause"><span class="std std-ref">WHERE 子句</span></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(address_table.c.email_address)</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table, user_table.c.id == address_table.c.user_id)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<div class="orm-header docutils container">
<p><strong>ORM Tip</strong> - there’s another way to generate the ON clause when using
ORM entities that make use of the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> construct,
like the mapping set up in the previous section at
<a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a>.
This is a whole subject onto itself, which is introduced at length
at <a class="reference internal" href="orm_related_objects.html#tutorial-joining-relationships"><span class="std std-ref">使用关系进行连接</span></a>.</p>
</div>
</div>
</div>
</section>
<section id="outer-full">
<h3>OUTER 和 FULL 连接<a class="headerlink" href="#outer-full" title="Link to this heading">¶</a></h3>
<p>OUTER and FULL join</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--9-input--1" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 方法都接受关键字参数 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.join.isouter</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.join.full</span></code></a>，分别渲染 LEFT OUTER JOIN 和 FULL OUTER JOIN:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">FULL</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>还有一个方法 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a> 等效于使用 <code class="docutils literal notranslate"><span class="pre">.join(...,</span> <span class="pre">isouter=True)</span></code>。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>SQL 还有一个 “RIGHT OUTER JOIN”。SQLAlchemy 不会直接渲染这个；而是反转表的顺序并使用 “LEFT OUTER JOIN”。</p>
</div>
</div>
<input class="tab-input" id="tab-set--9-input--2" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--2">英文</label><div class="tab-content docutils container">
<p>Both the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> methods
accept keyword arguments <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.isouter" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.join.isouter</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join.params.full" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Select.join.full</span></code></a> which will render LEFT OUTER JOIN
and FULL OUTER JOIN, respectively:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">address_table</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">FULL</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>There is also a method <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin" title="sqlalchemy.sql.expression.Select.outerjoin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.outerjoin()</span></code></a> that is equivalent to
using <code class="docutils literal notranslate"><span class="pre">.join(...,</span> <span class="pre">isouter=True)</span></code>.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>SQL also has a “RIGHT OUTER JOIN”.  SQLAlchemy doesn’t render this directly;
instead, reverse the order of the tables and use “LEFT OUTER JOIN”.</p>
</div>
</div>
</div>
</section>
</section>
<section id="order-bygroup-byhaving">
<span id="tutorial-order-by-group-by-having"></span><h2>ORDER BY、GROUP BY、HAVING<a class="headerlink" href="#order-bygroup-byhaving" title="Link to this heading">¶</a></h2>
<p>ORDER BY, GROUP BY, HAVING</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--10-input--1" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--1">中文</label><div class="tab-content docutils container">
<p>SELECT SQL 语句包含一个名为 ORDER BY 的子句，用于在给定的排序中返回选定的行。</p>
<p>GROUP BY 子句的构造类似于 ORDER BY 子句，其目的是将选定的行细分为特定的组，可以在这些组上调用聚合函数。HAVING 子句通常与 GROUP BY 一起使用，其形式类似于 WHERE 子句，只不过它应用于组内使用的聚合函数。</p>
</div>
<input class="tab-input" id="tab-set--10-input--2" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--2">英文</label><div class="tab-content docutils container">
<p>The SELECT SQL statement includes a clause called ORDER BY which is used to
return the selected rows within a given ordering.</p>
<p>The GROUP BY clause is constructed similarly to the ORDER BY clause, and has
the purpose of sub-dividing the selected rows into specific groups upon which
aggregate functions may be invoked. The HAVING clause is usually used with
GROUP BY and is of a similar form to the WHERE clause, except that it’s applied
to the aggregated functions used within groups.</p>
</div>
</div>
<section id="order-by">
<span id="tutorial-order-by"></span><h3>ORDER BY<a class="headerlink" href="#order-by" title="Link to this heading">¶</a></h3>
<p>ORDER BY</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--11-input--1" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--1">中文</label><div class="tab-content docutils container">
<p>ORDER BY 子句是根据通常基于 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 或类似对象的 SQL 表达式构造的。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a> 方法按位置接受一个或多个这些表达式:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
</div></pre></div>
</div>
<p>升序 / 降序可以通过 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc" title="sqlalchemy.sql.expression.ColumnElement.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.asc()</span></code></a> 和 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc" title="sqlalchemy.sql.expression.ColumnElement.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.desc()</span></code></a> 修饰符实现，这些修饰符也存在于 ORM 绑定属性中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="o">.</span><span class="n">desc</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">DESC</span>
</div></pre></div>
</div>
<p>上述语句将生成按 <code class="docutils literal notranslate"><span class="pre">user_account.fullname</span></code> 列降序排序的行。</p>
</div>
<input class="tab-input" id="tab-set--11-input--2" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--2">英文</label><div class="tab-content docutils container">
<p>The ORDER BY clause is constructed in terms
of SQL Expression constructs typically based on <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> or
similar objects.  The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a> method accepts one or
more of these expressions positionally:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
</div></pre></div>
</div>
<p>Ascending / descending is available from the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.asc" title="sqlalchemy.sql.expression.ColumnElement.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.asc()</span></code></a>
and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.desc" title="sqlalchemy.sql.expression.ColumnElement.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ColumnElement.desc()</span></code></a> modifiers, which are present
from ORM-bound attributes as well:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">fullname</span><span class="o">.</span><span class="n">desc</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">DESC</span>
</div></pre></div>
</div>
<p>The above statement will yield rows that are sorted by the
<code class="docutils literal notranslate"><span class="pre">user_account.fullname</span></code> column in descending order.</p>
</div>
</div>
</section>
<section id="group-by-having">
<span id="tutorial-group-by-w-aggregates"></span><h3>使用 GROUP BY / HAVING 的聚合函数<a class="headerlink" href="#group-by-having" title="Link to this heading">¶</a></h3>
<p>Aggregate functions with GROUP BY / HAVING</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--12-input--1" name="tab-set--12" type="radio"><label class="tab-label" for="tab-set--12-input--1">中文</label><div class="tab-content docutils container">
<p>在 SQL 中，聚合函数允许跨多行的列表达式聚合在一起以生成单个结果。示例包括计数、计算平均值以及在一组值中查找最大值或最小值。</p>
<p>SQLAlchemy 通过一个称为 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> 的命名空间以开放的方式提供 SQL 函数。这是一个特殊的构造对象，当给定特定 SQL 函数的名称时，它将创建 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> 的新实例，该名称可以是任何名称，并且可以传递零个或多个参数给函数，这些参数与所有其他情况一样，都是 SQL 表达式构造。例如，要对 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> 列呈现 SQL COUNT() 函数，我们调用 <code class="docutils literal notranslate"><span class="pre">count()</span></code> 名称:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count_fn</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">count_fn</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">count</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</div></pre></div>
</div>
<p>SQL 函数在本教程的后面部分 <a class="reference internal" href="#tutorial-functions"><span class="std std-ref">使用 SQL 函数</span></a> 中有更详细的描述。</p>
<p>在 SQL 中使用聚合函数时，GROUP BY 子句是必不可少的，因为它允许将行划分为组，每个组将单独应用聚合函数。当在 SELECT 语句的 COLUMNS 子句中请求非聚合列时，SQL 要求这些列都要受到 GROUP BY 子句的约束，无论是直接的还是基于主键关联的间接的。HAVING 子句的使用方式与 WHERE 子句类似，不同之处在于它根据聚合值而不是直接行内容过滤出行。</p>
<p>SQLAlchemy 通过 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.group_by" title="sqlalchemy.sql.expression.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.group_by()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.having" title="sqlalchemy.sql.expression.Select.having"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.having()</span></code></a> 方法提供这两个子句。下面我们展示选择用户名字段以及地址计数，对于那些有多个地址的用户：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(User.name, func.count(Address.id).label(&quot;count&quot;))</span>
<span class="go">...         .join(Address)</span>
<span class="go">...         .group_by(User.name)</span>
<span class="go">...         .having(func.count(Address.id) &gt; 1)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">[(&#39;sandy&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--12-input--2" name="tab-set--12" type="radio"><label class="tab-label" for="tab-set--12-input--2">英文</label><div class="tab-content docutils container">
<p>In SQL, aggregate functions allow column expressions across multiple rows
to be aggregated together to produce a single result.  Examples include
counting, computing averages, as well as locating the maximum or minimum
value in a set of values.</p>
<p>SQLAlchemy provides for SQL functions in an open-ended way using a namespace
known as <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a>.  This is a special constructor object which
will create new instances of <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> when given the name
of a particular SQL function, which can have any name, as well as zero or
more arguments to pass to the function, which are, like in all other cases,
SQL Expression constructs.   For example, to
render the SQL COUNT() function against the <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> column,
we call upon the <code class="docutils literal notranslate"><span class="pre">count()</span></code> name:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count_fn</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">count_fn</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">count</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</div></pre></div>
</div>
<p>SQL functions are described in more detail later in this tutorial at
<a class="reference internal" href="#tutorial-functions"><span class="std std-ref">使用 SQL 函数</span></a>.</p>
<p>When using aggregate functions in SQL, the GROUP BY clause is essential in that
it allows rows to be partitioned into groups where aggregate functions will
be applied to each group individually.  When requesting non-aggregated columns
in the COLUMNS clause of a SELECT statement, SQL requires that these columns
all be subject to a GROUP BY clause, either directly or indirectly based on
a primary key association.    The HAVING clause is then used in a similar
manner as the WHERE clause, except that it filters out rows based on aggregated
values rather than direct row contents.</p>
<p>SQLAlchemy provides for these two clauses using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.group_by" title="sqlalchemy.sql.expression.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.group_by()</span></code></a>
and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.having" title="sqlalchemy.sql.expression.Select.having"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.having()</span></code></a> methods.   Below we illustrate selecting
user name fields as well as count of addresses, for those users that have more
than one address:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(User.name, func.count(Address.id).label(&quot;count&quot;))</span>
<span class="go">...         .join(Address)</span>
<span class="go">...         .group_by(User.name)</span>
<span class="go">...         .having(func.count(Address.id) &gt; 1)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">[(&#39;sandy&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
</div>
</section>
<section id="tutorial-order-by-label">
<span id="id2"></span><h3>按标签排序或分组<a class="headerlink" href="#tutorial-order-by-label" title="Link to this heading">¶</a></h3>
<p>Ordering or Grouping by a Label</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--13-input--1" name="tab-set--13" type="radio"><label class="tab-label" for="tab-set--13-input--1">中文</label><div class="tab-content docutils container">
<p>一个重要的技术，尤其是在某些数据库后端，是能够对已经在列子句中声明的表达式进行 ORDER BY 或 GROUP BY，而无需在 ORDER BY 或 GROUP BY 子句中重新声明表达式，而是使用列子句中的列名或标签名。通过将名称的字符串文本传递给 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.group_by" title="sqlalchemy.sql.expression.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.group_by()</span></code></a> 方法，可以实现这种形式。传递的文本 <strong>不会直接渲染(not rendered directly)</strong> ；相反，列子句中给表达式的名称在上下文中渲染为该表达式的名称，如果没有找到匹配项，则会引发错误。单一修饰符 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.asc" title="sqlalchemy.sql.expression.asc"><code class="xref py py-func docutils literal notranslate"><span class="pre">asc()</span></code></a> 和 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.desc" title="sqlalchemy.sql.expression.desc"><code class="xref py py-func docutils literal notranslate"><span class="pre">desc()</span></code></a> 也可以以这种形式使用：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">desc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address.user_id, func.count(Address.id).label(&quot;num_addresses&quot;))</span>
<span class="go">...     .group_by(&quot;user_id&quot;)</span>
<span class="go">...     .order_by(&quot;user_id&quot;, desc(&quot;num_addresses&quot;))</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">num_addresses</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">num_addresses</span><span class="w"> </span><span class="k">DESC</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--13-input--2" name="tab-set--13" type="radio"><label class="tab-label" for="tab-set--13-input--2">英文</label><div class="tab-content docutils container">
<p>An important technique, in particular on some database backends, is the ability
to ORDER BY or GROUP BY an expression that is already stated in the columns
clause, without re-stating the expression in the ORDER BY or GROUP BY clause
and instead using the column name or labeled name from the COLUMNS clause.
This form is available by passing the string text of the name to the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.order_by" title="sqlalchemy.sql.expression.Select.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.order_by()</span></code></a> or <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.group_by" title="sqlalchemy.sql.expression.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.group_by()</span></code></a> method.  The text
passed is <strong>not rendered directly</strong>; instead, the name given to an expression
in the columns clause and rendered as that expression name in context, raising an
error if no match is found.   The unary modifiers
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.asc" title="sqlalchemy.sql.expression.asc"><code class="xref py py-func docutils literal notranslate"><span class="pre">asc()</span></code></a> and <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.desc" title="sqlalchemy.sql.expression.desc"><code class="xref py py-func docutils literal notranslate"><span class="pre">desc()</span></code></a> may also be used in this form:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">func</span><span class="p">,</span> <span class="n">desc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address.user_id, func.count(Address.id).label(&quot;num_addresses&quot;))</span>
<span class="go">...     .group_by(&quot;user_id&quot;)</span>
<span class="go">...     .order_by(&quot;user_id&quot;, desc(&quot;num_addresses&quot;))</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">num_addresses</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">num_addresses</span><span class="w"> </span><span class="k">DESC</span>
</div></pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="tutorial-using-aliases">
<span id="id3"></span><h2>使用别名<a class="headerlink" href="#tutorial-using-aliases" title="Link to this heading">¶</a></h2>
<p>Using Aliases</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--14-input--1" name="tab-set--14" type="radio"><label class="tab-label" for="tab-set--14-input--1">中文</label><div class="tab-content docutils container">
<p>现在我们从多个表中选择并使用连接时，很快就会遇到需要在语句的 FROM 子句中多次引用同一个表的情况。我们使用 SQL <strong>别名(aliases)</strong> 来完成这项工作，这是一种为表或子查询提供替代名称的语法，可以在语句中引用它。</p>
<p>在 SQLAlchemy 表达式语言中，这些“名称”由称为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 构造的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> 对象表示，在 Core 中使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> 方法构造。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 构造就像 <code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code> 构造一样，它在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Alias.c</span></code> 集合中也包含一个 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> 对象的命名空间。例如，下面的 SELECT 语句返回所有唯一的用户名对:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_1</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_2</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(user_alias_1.c.name, user_alias_2.c.name).join_from(</span>
<span class="go">...         user_alias_1, user_alias_2, user_alias_1.c.id &gt; user_alias_2.c.id</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_2</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">user_account_2</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--14-input--2" name="tab-set--14" type="radio"><label class="tab-label" for="tab-set--14-input--2">英文</label><div class="tab-content docutils container">
<p>Now that we are selecting from multiple tables and using joins, we quickly
run into the case where we need to refer to the same table multiple times
in the FROM clause of a statement.  We accomplish this using SQL <strong>aliases</strong>,
which are a syntax that supplies an alternative name to a table or subquery
from which it can be referenced in the statement.</p>
<p>In the SQLAlchemy Expression Language, these “names” are instead represented by
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> objects known as the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct,
which is constructed in Core using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a>
method. An <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct is just like a <code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code>
construct in that it also has a namespace of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
objects within the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Alias.c</span></code> collection.  The SELECT statement
below for example returns all unique pairs of user names:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_1</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias_2</span> <span class="o">=</span> <span class="n">user_table</span><span class="o">.</span><span class="n">alias</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(user_alias_1.c.name, user_alias_2.c.name).join_from(</span>
<span class="go">...         user_alias_1, user_alias_2, user_alias_1.c.id &gt; user_alias_2.c.id</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_2</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">user_account_2</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
</div>
</div>
<section id="tutorial-orm-entity-aliases">
<span id="id4"></span><h3>ORM 实体别名<a class="headerlink" href="#tutorial-orm-entity-aliases" title="Link to this heading">¶</a></h3>
<p>ORM Entity Aliases</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--15-input--1" name="tab-set--15" type="radio"><label class="tab-label" for="tab-set--15-input--1">中文</label><div class="tab-content docutils container">
<p>ORM 等效于 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> 方法的是 ORM <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 函数，可以应用于 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 等实体。这会在内部生成一个针对原始映射 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 对象，同时保持 ORM 功能。下面的 SELECT 语句从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 实体中选择包含两个特定电子邮件地址的所有对象:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">aliased</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(User)</span>
<span class="go">...     .join_from(User, address_alias_1)</span>
<span class="go">...     .where(address_alias_1.email_address == &quot;patrick@aol.com&quot;)</span>
<span class="go">...     .join_from(User, address_alias_2)</span>
<span class="go">...     .where(address_alias_2.email_address == &quot;patrick@gmail.com&quot;)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_2</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address_1</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">email_address_1</span>
<span class="k">AND</span><span class="w"> </span><span class="n">address_2</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">email_address_2</span>
</div></pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>如 <a class="reference internal" href="#tutorial-select-join-onclause"><span class="std std-ref">设置 ON 子句</span></a> 中所述，ORM 提供了另一种使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造进行连接的方法。
上述使用别名的示例在 <a class="reference internal" href="../orm/queryguide/select.html#tutorial-joining-relationships-aliased"><span class="std std-ref">使用关系在别名目标之间进行连接</span></a> 中使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 进行演示。</p>
</div>
</div>
<input class="tab-input" id="tab-set--15-input--2" name="tab-set--15" type="radio"><label class="tab-label" for="tab-set--15-input--2">英文</label><div class="tab-content docutils container">
<p>The ORM equivalent of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.alias" title="sqlalchemy.sql.expression.FromClause.alias"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FromClause.alias()</span></code></a> method is the
ORM <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> function, which may be applied to an entity
such as <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>.  This produces a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> object
internally that’s against the original mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object,
while maintaining ORM functionality.  The SELECT below selects from the
<code class="docutils literal notranslate"><span class="pre">User</span></code> entity all objects that include two particular email addresses:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">aliased</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_alias_2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     select(User)</span>
<span class="go">...     .join_from(User, address_alias_1)</span>
<span class="go">...     .where(address_alias_1.email_address == &quot;patrick@aol.com&quot;)</span>
<span class="go">...     .join_from(User, address_alias_2)</span>
<span class="go">...     .where(address_alias_2.email_address == &quot;patrick@gmail.com&quot;)</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address_2</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address_1</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">email_address_1</span>
<span class="k">AND</span><span class="w"> </span><span class="n">address_2</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">email_address_2</span>
</div></pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>As mentioned in <a class="reference internal" href="#tutorial-select-join-onclause"><span class="std std-ref">设置 ON 子句</span></a>, the ORM provides
for another way to join using the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> construct.
The above example using aliases is demonstrated using <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
at <a class="reference internal" href="../orm/queryguide/select.html#tutorial-joining-relationships-aliased"><span class="std std-ref">使用关系在别名目标之间进行连接</span></a>.</p>
</div>
</div>
</div>
</section>
</section>
<section id="cte">
<span id="tutorial-subqueries-ctes"></span><h2>子查询和 CTE<a class="headerlink" href="#cte" title="Link to this heading">¶</a></h2>
<p>Subqueries and CTEs</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--16-input--1" name="tab-set--16" type="radio"><label class="tab-label" for="tab-set--16-input--1">中文</label><div class="tab-content docutils container">
<p>SQL 中的子查询是一个在括号内呈现的 SELECT 语句，并放置在封闭语句的上下文中，通常是 SELECT 语句，但不一定是。</p>
<p>本节将介绍所谓的“非标量”子查询，通常放在封闭 SELECT 的 FROM 子句中。我们还将介绍公共表表达式（CTE），它的用法与子查询类似，但包含额外的功能。</p>
<p>SQLAlchemy 使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 对象来表示子查询，使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 来表示 CTE，通常分别从 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> 方法中获得。任何一个对象都可以作为较大的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造中的 FROM 元素使用。</p>
<p>我们可以构造一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 来选择 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中的行的聚合计数（聚合函数和 GROUP BY 在 <a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a> 中已介绍）：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>单独将子查询字符串化，而不是嵌入另一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 或其他语句中，会生成没有任何括号的普通 SELECT 语句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 对象的行为类似于任何其他 FROM 对象，如 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>，尤其是它包含一个选中列的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Subquery.c</span></code> 命名空间。我们可以使用这个命名空间来引用 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 列以及我们自定义标签的 <code class="docutils literal notranslate"><span class="pre">count</span></code> 表达式:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">subq</span></code> 对象中包含的行选择中，我们可以将对象应用于更大的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>，将数据连接到 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="go">...     user_table, subq</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>为了从 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 连接到 <code class="docutils literal notranslate"><span class="pre">address</span></code>，我们使用了 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 方法。如前所述，此连接的 ON 子句再次基于外键约束 <strong>推断(inferred)</strong> 。尽管 SQL 子查询本身没有任何约束，SQLAlchemy 可以通过确定 <code class="docutils literal notranslate"><span class="pre">subq.c.user_id</span></code> 列是从 <code class="docutils literal notranslate"><span class="pre">address_table.c.user_id</span></code> 列 <strong>派生(derived)</strong> 的来作用于表示在列上的约束，该列确实表达了指回 <code class="docutils literal notranslate"><span class="pre">user_table.c.id</span></code> 列的外键关系，然后用于生成 ON 子句。</p>
</div>
<input class="tab-input" id="tab-set--16-input--2" name="tab-set--16" type="radio"><label class="tab-label" for="tab-set--16-input--2">英文</label><div class="tab-content docutils container">
<p>A subquery in SQL is a SELECT statement that is rendered within parenthesis and
placed within the context of an enclosing statement, typically a SELECT
statement but not necessarily.</p>
<p>This section will cover a so-called “non-scalar” subquery, which is typically
placed in the FROM clause of an enclosing SELECT.   We will also cover the
Common Table Expression or CTE, which is used in a similar way as a subquery,
but includes additional features.</p>
<p>SQLAlchemy uses the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> object to represent a subquery and
the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> to represent a CTE, usually obtained from the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> methods, respectively.
Either object can be used as a FROM element inside of a larger
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct.</p>
<p>We can construct a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> that will select an aggregate count
of rows from the <code class="docutils literal notranslate"><span class="pre">address</span></code> table (aggregate functions and GROUP BY were
introduced previously at <a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a>):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">),</span> <span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">address_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>Stringifying the subquery by itself without it being embedded inside of another
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> or other statement produces the plain SELECT statement
without any enclosing parenthesis:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> object behaves like any other FROM object such
as a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, notably that it includes a <code class="xref py py-attr docutils literal notranslate"><span class="pre">Subquery.c</span></code>
namespace of the columns which it selects.  We can use this namespace to
refer to both the <code class="docutils literal notranslate"><span class="pre">user_id</span></code> column as well as our custom labeled
<code class="docutils literal notranslate"><span class="pre">count</span></code> expression:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>With a selection of rows contained within the <code class="docutils literal notranslate"><span class="pre">subq</span></code> object, we can apply
the object to a larger <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> that will join the data to
the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> table:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="go">...     user_table, subq</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>In order to join from <code class="docutils literal notranslate"><span class="pre">user_account</span></code> to <code class="docutils literal notranslate"><span class="pre">address</span></code>, we made use of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> method.   As has been illustrated previously, the
ON clause of this join was again <strong>inferred</strong> based on foreign key constraints.
Even though a SQL subquery does not itself have any constraints, SQLAlchemy can
act upon constraints represented on the columns by determining that the
<code class="docutils literal notranslate"><span class="pre">subq.c.user_id</span></code> column is <strong>derived</strong> from the <code class="docutils literal notranslate"><span class="pre">address_table.c.user_id</span></code>
column, which does express a foreign key relationship back to the
<code class="docutils literal notranslate"><span class="pre">user_table.c.id</span></code> column which is then used to generate the ON clause.</p>
</div>
</div>
<section id="id5">
<h3>通用表表达式 (CTE)<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h3>
<p>Common Table Expressions (CTEs)</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--17-input--1" name="tab-set--17" type="radio"><label class="tab-label" for="tab-set--17-input--1">中文</label><div class="tab-content docutils container">
<p>在 SQLAlchemy 中，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 构造的用法与 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 构造几乎相同。通过将 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> 方法的调用更改为使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a>，我们可以以相同的方式使用生成的对象作为 FROM 元素，但渲染的 SQL 是非常不同的公共表表达式语法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id).label(&quot;count&quot;), address_table.c.user_id)</span>
<span class="go">...     .group_by(address_table.c.user_id)</span>
<span class="go">...     .cte()</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="go">...     user_table, subq</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">WITH</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 构造还具有以“递归”样式使用的能力，并且在更复杂的情况下可以从 INSERT、UPDATE 或 DELETE 语句的 RETURNING 子句中组成。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 的文档字符串中包含有关这些附加模式的详细信息。</p>
<p>在这两种情况下，子查询和 CTE 在 SQL 级别使用“匿名”名称命名。在 Python 代码中，我们根本不需要提供这些名称。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 实例的对象标识在渲染时作为对象的语法标识。如果传递名称作为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> 方法的第一个参数，则可以在 SQL 中渲染该名称。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> - 有关子查询的更多详细信息</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> - 包括如何使用 RECURSIVE 以及面向 DML 的 CTE 的示例</p>
</div>
</div>
<input class="tab-input" id="tab-set--17-input--2" name="tab-set--17" type="radio"><label class="tab-label" for="tab-set--17-input--2">英文</label><div class="tab-content docutils container">
<p>Usage of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct in SQLAlchemy is virtually
the same as how the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> construct is used.  By changing
the invocation of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> method to use
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> instead, we can use the resulting object as a FROM
element in the same way, but the SQL rendered is the very different common
table expression syntax:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id).label(&quot;count&quot;), address_table.c.user_id)</span>
<span class="go">...     .group_by(address_table.c.user_id)</span>
<span class="go">...     .cte()</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">fullname</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span>
<span class="go">...     user_table, subq</span>
<span class="go">... )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">WITH</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="k">count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct also features the ability to be used
in a “recursive” style, and may in more elaborate cases be composed from the
RETURNING clause of an INSERT, UPDATE or DELETE statement.  The docstring
for <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> includes details on these additional patterns.</p>
<p>In both cases, the subquery and CTE were named at the SQL level using an
“anonymous” name.  In the Python code, we don’t need to provide these names
at all.  The object identity of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> or <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a>
instances serves as the syntactical identity of the object when rendered.
A name that will be rendered in the SQL can be provided by passing it as the
first argument of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> or <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> methods.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.subquery" title="sqlalchemy.sql.expression.Select.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.subquery()</span></code></a> - further detail on subqueries</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.cte" title="sqlalchemy.sql.expression.Select.cte"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.cte()</span></code></a> - examples for CTE including how to use RECURSIVE as well as DML-oriented CTEs</p>
</div>
</div>
</div>
</section>
<section id="orm-cte">
<span id="tutorial-subqueries-orm-aliased"></span><h3>ORM 实体子查询/CTE<a class="headerlink" href="#orm-cte" title="Link to this heading">¶</a></h3>
<p>ORM Entity Subqueries/CTEs</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--18-input--1" name="tab-set--18" type="radio"><label class="tab-label" for="tab-set--18-input--1">中文</label><div class="tab-content docutils container">
<p>在 ORM 中，<a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 构造可用于将 ORM 实体（例如我们的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 或 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类）与表示行源的任何 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> 概念关联。前一节 <a class="reference internal" href="#tutorial-orm-entity-aliases"><span class="std std-ref">ORM 实体别名</span></a> 说明了使用 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 将映射类与其映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 关联。在这里，我们说明 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 对 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 的应用，这些都是针对 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造生成的，最终派生自相同的映射 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>。</p>
<p>下面是将 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 应用于 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 构造的示例，以便从其行中提取 ORM 实体。结果显示了一系列 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，其中每个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象的数据最终来自对 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表的子查询，而不是直接来自该表：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;%@aol.com&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_subq</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">subq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(User, address_subq)</span>
<span class="go">...     .join_from(User, address_subq)</span>
<span class="go">...     .order_by(User.id, address_subq.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for user, address in session.execute(stmt):</span>
<span class="go">...         print(f&quot;{user} {address}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;) Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>下面是一个相同的示例，只是它使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> 构造：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cte_obj</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;%@aol.com&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">cte</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_cte</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">cte_obj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(User, address_cte)</span>
<span class="go">...     .join_from(User, address_cte)</span>
<span class="go">...     .order_by(User.id, address_cte.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for user, address in session.execute(stmt):</span>
<span class="go">...         print(f&quot;{user} {address}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">WITH</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;) Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-subqueries"><span class="std std-ref">从子查询中选择实体</span></a> - 在 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中</p>
</div>
</div>
<input class="tab-input" id="tab-set--18-input--2" name="tab-set--18" type="radio"><label class="tab-label" for="tab-set--18-input--2">英文</label><div class="tab-content docutils container">
<p>In the ORM, the <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> construct may be used to associate an ORM
entity, such as our <code class="docutils literal notranslate"><span class="pre">User</span></code> or <code class="docutils literal notranslate"><span class="pre">Address</span></code> class, with any <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a>
concept that represents a source of rows.  The preceding section
<a class="reference internal" href="#tutorial-orm-entity-aliases"><span class="std std-ref">ORM 实体别名</span></a> illustrates using <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a>
to associate the mapped class with an <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> of its
mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.   Here we illustrate <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> doing the same
thing against both a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> as well as a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a>
generated against a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct, that ultimately derives
from that same mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.</p>
<p>Below is an example of applying <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> to the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a>
construct, so that ORM entities can be extracted from its rows.  The result
shows a series of <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> objects, where the data for
each <code class="docutils literal notranslate"><span class="pre">Address</span></code> object ultimately came from a subquery against the
<code class="docutils literal notranslate"><span class="pre">address</span></code> table rather than that table directly:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;%@aol.com&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_subq</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">subq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(User, address_subq)</span>
<span class="go">...     .join_from(User, address_subq)</span>
<span class="go">...     .order_by(User.id, address_subq.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for user, address in session.execute(stmt):</span>
<span class="go">...         print(f&quot;{user} {address}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;) Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>Another example follows, which is exactly the same except it makes use of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CTE" title="sqlalchemy.sql.expression.CTE"><code class="xref py py-class docutils literal notranslate"><span class="pre">CTE</span></code></a> construct instead:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cte_obj</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s2">&quot;%@aol.com&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">cte</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_cte</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">cte_obj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(User, address_cte)</span>
<span class="go">...     .join_from(User, address_cte)</span>
<span class="go">...     .order_by(User.id, address_cte.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for user, address in session.execute(stmt):</span>
<span class="go">...         print(f&quot;{user} {address}&quot;)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">WITH</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">AS</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;%@aol.com&#39;</span><span class="p">,)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;) Address(id=1, email_address=&#39;spongebob@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=2, email_address=&#39;sandy@sqlalchemy.org&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;) Address(id=3, email_address=&#39;sandy@squirrelpower.org&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-subqueries"><span class="std std-ref">从子查询中选择实体</span></a> - in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
</div>
</section>
</section>
<section id="tutorial-scalar-subquery">
<span id="id6"></span><h2>标量和相关子查询<a class="headerlink" href="#tutorial-scalar-subquery" title="Link to this heading">¶</a></h2>
<p>Scalar and Correlated Subqueries</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--19-input--1" name="tab-set--19" type="radio"><label class="tab-label" for="tab-set--19-input--1">中文</label><div class="tab-content docutils container">
<p>标量子查询是一个返回零或一行且仅包含一列的子查询。然后，该子查询在封闭的 SELECT 语句的 COLUMNS 或 WHERE 子句中使用，与常规子查询不同，它不在 FROM 子句中使用。<a class="reference internal" href="../glossary.html#term-43"><span class="xref std std-term">相关子查询</span></a> 是一个标量子查询，它引用封闭 SELECT 语句中的表。</p>
<p>SQLAlchemy 使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> 构造来表示标量子查询，它是 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> 表达式层次结构的一部分，而常规子查询由 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 构造表示，它属于 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> 层次结构。</p>
<p>标量子查询通常（但不一定）与聚合函数一起使用，前面在 <a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a> 中介绍过。通过使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery" title="sqlalchemy.sql.expression.Select.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.scalar_subquery()</span></code></a> 方法明确指示标量子查询，如下所示。其默认字符串形式在单独字符串化时呈现为从两个表中选择的普通 SELECT 语句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<div class='show_sql_print'><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
</div></pre></div>
</div>
<p>上述 <code class="docutils literal notranslate"><span class="pre">subq</span></code> 对象现在位于 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> SQL 表达式层次结构中，可以像任何其他列表达式一样使用:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<div class='show_sql_print'><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">param_1</span>
</div></pre></div>
</div>
<p>尽管标量子查询本身在字符串化时会在其 FROM 子句中呈现 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span></code>，但当将其嵌入到处理 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表的封闭 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造中时，<code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表会自动 <strong>关联(correlated)</strong> ，这意味着它不会在子查询的 FROM 子句中呈现:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;address_count&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>简单的相关子查询通常会做出所需的正确操作。然而，在关联不明确的情况下，SQLAlchemy 会让我们知道需要更多的清晰度:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         subq.label(&quot;address_count&quot;),</span>
<span class="go">...     )</span>
<span class="go">...     .join_from(user_table, address_table)</span>
<span class="go">...     .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">InvalidRequestError: Select statement &#39;&lt;... Select object at ...&gt;&#39; returned</span>
<span class="go">no FROM clauses due to auto-correlation; specify correlate(&lt;tables&gt;) to</span>
<span class="go">control correlation manually.</span></pre></div>
</div>
<p>要指定我们希望关联的表是 <code class="docutils literal notranslate"><span class="pre">user_table</span></code>，我们可以使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate" title="sqlalchemy.sql.expression.ScalarSelect.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScalarSelect.correlate()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except" title="sqlalchemy.sql.expression.ScalarSelect.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScalarSelect.correlate_except()</span></code></a> 方法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">...     .correlate(user_table)</span>
<span class="go">... )</span></pre></div>
</div>
<p>然后，该语句可以像任何其他列一样返回此列的数据：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(</span>
<span class="go">...             user_table.c.name,</span>
<span class="go">...             address_table.c.email_address,</span>
<span class="go">...             subq.label(&quot;address_count&quot;),</span>
<span class="go">...         )</span>
<span class="go">...         .join_from(user_table, address_table)</span>
<span class="go">...         .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;, 1), (&#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;, 2),</span>
<span class="go">(&#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--19-input--2" name="tab-set--19" type="radio"><label class="tab-label" for="tab-set--19-input--2">英文</label><div class="tab-content docutils container">
<p>A scalar subquery is a subquery that returns exactly zero or one row and
exactly one column.  The subquery is then used in the COLUMNS or WHERE clause
of an enclosing SELECT statement and is different than a regular subquery in
that it is not used in the FROM clause.   A <a class="reference internal" href="../glossary.html#term-correlated-subquery"><span class="xref std std-term">correlated subquery</span></a> is a
scalar subquery that refers to a table in the enclosing SELECT statement.</p>
<p>SQLAlchemy represents the scalar subquery using the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> construct, which is part of the
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a> expression hierarchy, in contrast to the regular
subquery which is represented by the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> construct, which is
in the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause" title="sqlalchemy.sql.expression.FromClause"><code class="xref py py-class docutils literal notranslate"><span class="pre">FromClause</span></code></a> hierarchy.</p>
<p>Scalar subqueries are often, but not necessarily, used with aggregate functions,
introduced previously at <a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a>.   A scalar
subquery is indicated explicitly by making use of the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.scalar_subquery" title="sqlalchemy.sql.expression.Select.scalar_subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.scalar_subquery()</span></code></a>
method as below.  It’s default string form when stringified by itself
renders as an ordinary SELECT statement that is selecting from two tables:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span><span class="p">)</span>
<div class='show_sql_print'><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
</div></pre></div>
</div>
<p>The above <code class="docutils literal notranslate"><span class="pre">subq</span></code> object now falls within the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement" title="sqlalchemy.sql.expression.ColumnElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ColumnElement</span></code></a>
SQL expression hierarchy, in that it may be used like any other column
expression:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">subq</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<div class='show_sql_print'><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">param_1</span>
</div></pre></div>
</div>
<p>Although the scalar subquery by itself renders both <code class="docutils literal notranslate"><span class="pre">user_account</span></code> and
<code class="docutils literal notranslate"><span class="pre">address</span></code> in its FROM clause when stringified by itself, when embedding it
into an enclosing <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct that deals with the
<code class="docutils literal notranslate"><span class="pre">user_account</span></code> table, the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> table is automatically
<strong>correlated</strong>, meaning it does not render in the FROM clause of the subquery:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">subq</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s2">&quot;address_count&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>Simple correlated subqueries will usually do the right thing that’s desired.
However, in the case where the correlation is ambiguous, SQLAlchemy will let
us know that more clarity is needed:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         subq.label(&quot;address_count&quot;),</span>
<span class="go">...     )</span>
<span class="go">...     .join_from(user_table, address_table)</span>
<span class="go">...     .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">InvalidRequestError: Select statement &#39;&lt;... Select object at ...&gt;&#39; returned</span>
<span class="go">no FROM clauses due to auto-correlation; specify correlate(&lt;tables&gt;) to</span>
<span class="go">control correlation manually.</span></pre></div>
</div>
<p>To specify that the <code class="docutils literal notranslate"><span class="pre">user_table</span></code> is the one we seek to correlate we specify
this using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate" title="sqlalchemy.sql.expression.ScalarSelect.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScalarSelect.correlate()</span></code></a> or
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect.correlate_except" title="sqlalchemy.sql.expression.ScalarSelect.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ScalarSelect.correlate_except()</span></code></a> methods:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .scalar_subquery()</span>
<span class="go">...     .correlate(user_table)</span>
<span class="go">... )</span></pre></div>
</div>
<p>The statement then can return the data for this column like any other:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(</span>
<span class="go">...         select(</span>
<span class="go">...             user_table.c.name,</span>
<span class="go">...             address_table.c.email_address,</span>
<span class="go">...             subq.label(&quot;address_count&quot;),</span>
<span class="go">...         )</span>
<span class="go">...         .join_from(user_table, address_table)</span>
<span class="go">...         .order_by(user_table.c.id, address_table.c.id)</span>
<span class="go">...     )</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;, 1), (&#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;, 2),</span>
<span class="go">(&#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;, 2)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
</div>
<section id="lateral">
<span id="tutorial-lateral-correlation"></span><h3>LATERAL 相关<a class="headerlink" href="#lateral" title="Link to this heading">¶</a></h3>
<p>LATERAL correlation</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--20-input--1" name="tab-set--20" type="radio"><label class="tab-label" for="tab-set--20-input--1">中文</label><div class="tab-content docutils container">
<p>LATERAL 关联是 SQL 关联的一个特殊子类别，允许选择单元在单个 FROM 子句中引用另一个选择单元。这是一个非常特殊的用例，虽然是 SQL 标准的一部分，但已知只有 PostgreSQL 的最新版本支持。</p>
<p>通常，如果 SELECT 语句在其 FROM 子句中引用 <code class="docutils literal notranslate"><span class="pre">table1</span> <span class="pre">JOIN</span> <span class="pre">(SELECT</span> <span class="pre">...)</span> <span class="pre">AS</span> <span class="pre">subquery</span></code>，则右侧的子查询可能不会引用左侧的 “table1” 表达式；关联可能只引用完全封闭此 SELECT 的另一个 SELECT 的表。LATERAL 关键字允许我们改变这种行为，并允许从右侧 JOIN 进行关联。</p>
<p>SQLAlchemy 使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a> 方法支持此功能，该方法创建一个称为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a> 的对象。<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a> 属于与 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 相同的家族，但在将构造添加到封闭 SELECT 的 FROM 子句时，也包括关联行为。以下示例说明了一个使用 LATERAL 的 SQL 查询，选择“用户账户 / 电子邮件地址计数”数据，如前一节所述:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.id).label(&quot;address_count&quot;),</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         address_table.c.user_id,</span>
<span class="go">...     )</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .lateral()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(user_table.c.name, subq.c.address_count, subq.c.email_address)</span>
<span class="go">...     .join_from(user_table, subq)</span>
<span class="go">...     .order_by(user_table.c.id, subq.c.email_address)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">address_count</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="k">LATERAL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
</div></pre></div>
</div>
<p>上述示例中，JOIN 的右侧是一个关联到 JOIN 左侧 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表的子查询。</p>
<p>使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a> 时，<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a> 方法的行为也适用于 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a> 构造。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a></p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--20-input--2" name="tab-set--20" type="radio"><label class="tab-label" for="tab-set--20-input--2">英文</label><div class="tab-content docutils container">
<p>LATERAL correlation is a special sub-category of SQL correlation which
allows a selectable unit to refer to another selectable unit within a
single FROM clause.  This is an extremely special use case which, while
part of the SQL standard, is only known to be supported by recent
versions of PostgreSQL.</p>
<p>Normally, if a SELECT statement refers to
<code class="docutils literal notranslate"><span class="pre">table1</span> <span class="pre">JOIN</span> <span class="pre">(SELECT</span> <span class="pre">...)</span> <span class="pre">AS</span> <span class="pre">subquery</span></code> in its FROM clause, the subquery
on the right side may not refer to the “table1” expression from the left side;
correlation may only refer to a table that is part of another SELECT that
entirely encloses this SELECT.  The LATERAL keyword allows us to turn this
behavior around and allow correlation from the right side JOIN.</p>
<p>SQLAlchemy supports this feature using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a>
method, which creates an object known as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a>. <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a>
is in the same family as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a>, but also
includes correlation behavior when the construct is added to the FROM clause of
an enclosing SELECT. The following example illustrates a SQL query that makes
use of LATERAL, selecting the “user account / count of email address” data as
was discussed in the previous section:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.id).label(&quot;address_count&quot;),</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...         address_table.c.user_id,</span>
<span class="go">...     )</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .lateral()</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(user_table.c.name, subq.c.address_count, subq.c.email_address)</span>
<span class="go">...     .join_from(user_table, subq)</span>
<span class="go">...     .order_by(user_table.c.id, subq.c.email_address)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">address_count</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">JOIN</span><span class="w"> </span><span class="k">LATERAL</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_count</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">email_address</span>
</div></pre></div>
</div>
<p>Above, the right side of the JOIN is a subquery that correlates to the
<code class="docutils literal notranslate"><span class="pre">user_account</span></code> table that’s on the left side of the join.</p>
<p>When using <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a>, the behavior of
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate" title="sqlalchemy.sql.expression.Select.correlate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except" title="sqlalchemy.sql.expression.Select.correlate_except"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.correlate_except()</span></code></a> methods is applied to the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a> construct as well.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Lateral" title="sqlalchemy.sql.expression.Lateral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lateral</span></code></a></p>
<p><a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.lateral" title="sqlalchemy.sql.expression.Select.lateral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.lateral()</span></code></a></p>
</div>
</div>
</div>
</section>
</section>
<section id="unionunion-all">
<span id="tutorial-union"></span><h2>UNION、UNION ALL 和其他集合操作<a class="headerlink" href="#unionunion-all" title="Link to this heading">¶</a></h2>
<p>UNION, UNION ALL and other set operations</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--21-input--1" name="tab-set--21" type="radio"><label class="tab-label" for="tab-set--21-input--1">中文</label><div class="tab-content docutils container">
<p>在 SQL 中，SELECT 语句可以使用 UNION 或 UNION ALL SQL 操作合并在一起，从而生成一个或多个语句共同生成的所有行的集合。其他集合操作如 INTERSECT [ALL] 和 EXCEPT [ALL] 也是可能的。</p>
<p>SQLAlchemy 的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造通过函数如 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a>、<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect" title="sqlalchemy.sql.expression.intersect"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.except_" title="sqlalchemy.sql.expression.except_"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_()</span></code></a> 以及它们的“all”对应物 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a>、<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect_all" title="sqlalchemy.sql.expression.intersect_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect_all()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.except_all" title="sqlalchemy.sql.expression.except_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_all()</span></code></a> 支持这种性质的组合。这些函数都接受任意数量的子选择项，通常是 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造，但也可以是现有的组合。</p>
<p>这些函数生成的构造是 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a>，其使用方式与 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 构造相同，只是它的方法较少。例如，由 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a> 生成的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> 可以直接使用 <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a> 调用:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">union_all</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sandy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union_all</span><span class="p">(</span><span class="n">stmt1</span><span class="p">,</span> <span class="n">stmt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(u)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(2, &#39;sandy&#39;, &#39;Sandy Cheeks&#39;), (1, &#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>要将 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> 用作子查询，就像 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 一样，它提供了一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> 方法，该方法将生成一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> 对象，并带有一个可以在封闭的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 中引用的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a> 集合:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u_subq</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(u_subq.c.name, address_table.c.email_address)</span>
<span class="go">...     .join_from(address_table, u_subq)</span>
<span class="go">...     .order_by(u_subq.c.name, address_table.c.email_address)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(&#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;), (&#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (&#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--21-input--2" name="tab-set--21" type="radio"><label class="tab-label" for="tab-set--21-input--2">英文</label><div class="tab-content docutils container">
<p>In SQL, SELECT statements can be merged together using the UNION or UNION ALL
SQL operation, which produces the set of all rows produced by one or more
statements together.  Other set operations such as INTERSECT [ALL] and
EXCEPT [ALL] are also possible.</p>
<p>SQLAlchemy’s <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct supports compositions of this
nature using functions like <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union" title="sqlalchemy.sql.expression.union"><code class="xref py py-func docutils literal notranslate"><span class="pre">union()</span></code></a>, <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect" title="sqlalchemy.sql.expression.intersect"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect()</span></code></a> and
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.except_" title="sqlalchemy.sql.expression.except_"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_()</span></code></a>, and the “all” counterparts <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a>,
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.intersect_all" title="sqlalchemy.sql.expression.intersect_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">intersect_all()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.except_all" title="sqlalchemy.sql.expression.except_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">except_all()</span></code></a>. These functions all
accept an arbitrary number of sub-selectables, which are typically
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> constructs but may also be an existing composition.</p>
<p>The construct produced by these functions is the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a>,
which is used in the same manner as the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> construct, except
that it has fewer methods.   The <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> produced by
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.union_all" title="sqlalchemy.sql.expression.union_all"><code class="xref py py-func docutils literal notranslate"><span class="pre">union_all()</span></code></a> for example may be invoked directly using
<a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Connection.execute" title="sqlalchemy.engine.Connection.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Connection.execute()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">union_all</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sandy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_table</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union_all</span><span class="p">(</span><span class="n">stmt1</span><span class="p">,</span> <span class="n">stmt2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(u)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(2, &#39;sandy&#39;, &#39;Sandy Cheeks&#39;), (1, &#39;spongebob&#39;, &#39;Spongebob Squarepants&#39;)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>To use a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> as a subquery, just like <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a>
it provides a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery" title="sqlalchemy.sql.expression.SelectBase.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.subquery()</span></code></a> method which will produce a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Subquery" title="sqlalchemy.sql.expression.Subquery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Subquery</span></code></a> object with a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.FromClause.c" title="sqlalchemy.sql.expression.FromClause.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FromClause.c</span></code></a>
collection that may be referenced in an enclosing <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u_subq</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">subquery</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(u_subq.c.name, address_table.c.email_address)</span>
<span class="go">...     .join_from(address_table, u_subq)</span>
<span class="go">...     .order_by(u_subq.c.name, address_table.c.email_address)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span>
<span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(&#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;), (&#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (&#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
</div>
<section id="tutorial-orm-union">
<span id="id7"></span><h3>从联合中选择 ORM 实体<a class="headerlink" href="#tutorial-orm-union" title="Link to this heading">¶</a></h3>
<p>Selecting ORM Entities from Unions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--22-input--1" name="tab-set--22" type="radio"><label class="tab-label" for="tab-set--22-input--1">中文</label><div class="tab-content docutils container">
<p>前面的示例说明了如何构造给定两个 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象的 UNION，以返回数据库行。如果我们想使用 UNION 或其他集合操作选择行，然后作为 ORM 对象接收它们，有两种方法可以使用。在这两种情况下，我们首先构造一个表示我们要执行的 SELECT / UNION / 等语句的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> 对象；该语句应针对目标 ORM 实体或其底层映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象组成:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sandy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union_all</span><span class="p">(</span><span class="n">stmt1</span><span class="p">,</span> <span class="n">stmt2</span><span class="p">)</span></pre></div>
</div>
<p>对于未嵌套在子查询内的简单 SELECT with UNION，通常可以使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a> 方法在 ORM 对象获取上下文中使用它们。通过这种方法，UNION 语句表示整个查询；在使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a> 后不能添加其他条件:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;)</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>要以更灵活的方式使用 UNION 或其他集合相关构造作为实体相关组件，可以使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery" title="sqlalchemy.sql.expression.CompoundSelect.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CompoundSelect.subquery()</span></code></a> 方法将 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> 构造组织成子查询，然后使用 <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> 函数链接到 ORM 对象。这与 <a class="reference internal" href="#tutorial-subqueries-orm-aliased"><span class="std std-ref">ORM 实体子查询/CTE</span></a> 中介绍的方式相同，首先创建我们所需实体到子查询的临时“映射”，然后像选择其他映射类一样从该新实体中选择。在下面的示例中，我们可以在 UNION 本身之外添加其他条件（如 ORDER BY），因为我们可以过滤或按子查询导出的列排序:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subquery</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_alias</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-unions"><span class="std std-ref">从 UNION 和其他集合操作中选择实体</span></a> - 在 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--22-input--2" name="tab-set--22" type="radio"><label class="tab-label" for="tab-set--22-input--2">英文</label><div class="tab-content docutils container">
<p>The preceding examples illustrated how to construct a UNION given two
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects, to then return database rows.  If we wanted
to use a UNION or other set operation to select rows that we then receive
as ORM objects, there are two approaches that may be used.  In both cases,
we first construct a <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> or <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a>
object that represents the SELECT / UNION / etc statement we want to
execute; this statement should be composed against the target
ORM entities or their underlying mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;sandy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;spongebob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">union_all</span><span class="p">(</span><span class="n">stmt1</span><span class="p">,</span> <span class="n">stmt2</span><span class="p">)</span></pre></div>
</div>
<p>For a simple SELECT with UNION that is not already nested inside of a
subquery, these
can often be used in an ORM object fetching context by using the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a> method.  With this approach, the UNION
statement represents the entire query; no additional
criteria can be added after <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.from_statement" title="sqlalchemy.sql.expression.Select.from_statement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.from_statement()</span></code></a> is used:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">from_statement</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;)</span>
<span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>To use a UNION or other set-related construct as an entity-related component in
in a more flexible manner, the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect" title="sqlalchemy.sql.expression.CompoundSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompoundSelect</span></code></a> construct may be
organized into a subquery using <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.CompoundSelect.subquery" title="sqlalchemy.sql.expression.CompoundSelect.subquery"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CompoundSelect.subquery()</span></code></a>, which
then links to ORM objects using the <a class="reference internal" href="../orm/queryguide/api.html#sqlalchemy.orm.aliased" title="sqlalchemy.orm.aliased"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliased()</span></code></a> function. This works
in the same way introduced at <a class="reference internal" href="#tutorial-subqueries-orm-aliased"><span class="std std-ref">ORM 实体子查询/CTE</span></a>, to first
create an ad-hoc “mapping” of our desired entity to the subquery, then
selecting from that new entity as though it were any other mapped class.
In the example below, we are able to add additional criteria such as ORDER BY
outside of the UNION itself, as we can filter or order by the columns exported
by the subquery:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_alias</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">subquery</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orm_stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">user_alias</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">user_alias</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Session</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
<span class="go">...     for obj in session.execute(orm_stmt).scalars():</span>
<span class="go">...         print(obj)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">id</span>
<span class="p">[</span><span class="k">generated</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">User(id=1, name=&#39;spongebob&#39;, fullname=&#39;Spongebob Squarepants&#39;)</span>
<span class="go">User(id=2, name=&#39;sandy&#39;, fullname=&#39;Sandy Cheeks&#39;)</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-unions"><span class="std std-ref">从 UNION 和其他集合操作中选择实体</span></a> - in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
</div>
</section>
</section>
<section id="exists">
<span id="tutorial-exists"></span><h2>EXISTS 子查询<a class="headerlink" href="#exists" title="Link to this heading">¶</a></h2>
<p>EXISTS subqueries</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--23-input--1" name="tab-set--23" type="radio"><label class="tab-label" for="tab-set--23-input--1">中文</label><div class="tab-content docutils container">
<p>SQL EXISTS 关键字是一个运算符，用于 <a class="reference internal" href="#tutorial-scalar-subquery"><span class="std std-ref">标量子查询</span></a>，根据 SELECT 语句是否返回行来返回布尔值 true 或 false。SQLAlchemy 包含 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> 对象的变体，称为 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Exists" title="sqlalchemy.sql.expression.Exists"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exists</span></code></a>，它将生成一个 EXISTS 子查询，并且最方便的是使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists" title="sqlalchemy.sql.expression.SelectBase.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.exists()</span></code></a> 方法生成。下面我们生成一个 EXISTS，以便返回在 <code class="docutils literal notranslate"><span class="pre">address</span></code> 中有多于一行相关行的 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .group_by(address_table.c.user_id)</span>
<span class="go">...     .having(func.count(address_table.c.id) &gt; 1)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">[(&#39;sandy&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>EXISTS 构造更多地用作否定，例如 NOT EXISTS，因为它提供了一种 SQL 高效形式，用于查找相关表没有行的行。下面我们选择没有电子邮件地址的用户名；请注意在第二个 WHERE 子句中使用的二元否定运算符（ <code class="docutils literal notranslate"><span class="pre">~</span></code> ）：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(address_table.c.id).where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(~subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="p">(</span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">))</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;patrick&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--23-input--2" name="tab-set--23" type="radio"><label class="tab-label" for="tab-set--23-input--2">英文</label><div class="tab-content docutils container">
<p>The SQL EXISTS keyword is an operator that is used with <a class="reference internal" href="#tutorial-scalar-subquery"><span class="std std-ref">scalar subqueries</span></a> to return a boolean true or false depending on if
the SELECT statement would return a row.  SQLAlchemy includes a variant of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.ScalarSelect" title="sqlalchemy.sql.expression.ScalarSelect"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScalarSelect</span></code></a> object called <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Exists" title="sqlalchemy.sql.expression.Exists"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exists</span></code></a>, which will
generate an EXISTS subquery and is most conveniently generated using the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.SelectBase.exists" title="sqlalchemy.sql.expression.SelectBase.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SelectBase.exists()</span></code></a> method.  Below we produce an EXISTS so that we
can return <code class="docutils literal notranslate"><span class="pre">user_account</span></code> rows that have more than one related row in
<code class="docutils literal notranslate"><span class="pre">address</span></code>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(func.count(address_table.c.id))</span>
<span class="go">...     .where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">...     .group_by(address_table.c.user_id)</span>
<span class="go">...     .having(func.count(address_table.c.id) &gt; 1)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</div><span class="go">[(&#39;sandy&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>The EXISTS construct is more often than not used as a negation, e.g. NOT EXISTS,
as it provides a SQL-efficient form of locating rows for which a related
table has no rows.  Below we select user names that have no email addresses;
note the binary negation operator (<code class="docutils literal notranslate"><span class="pre">~</span></code>) used inside the second WHERE
clause:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subq</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(address_table.c.id).where(user_table.c.id == address_table.c.user_id)</span>
<span class="go">... ).exists()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(select(user_table.c.name).where(~subq))</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="p">(</span><span class="k">EXISTS</span><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">))</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;patrick&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
</div>
</section>
<section id="tutorial-functions">
<span id="id8"></span><h2>使用 SQL 函数<a class="headerlink" href="#tutorial-functions" title="Link to this heading">¶</a></h2>
<p>Working with SQL Functions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--24-input--1" name="tab-set--24" type="radio"><label class="tab-label" for="tab-set--24-input--1">中文</label><div class="tab-content docutils container">
<p>在本节前面首次介绍的 <a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a>，<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> 对象用作创建新的 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> 对象的工厂，当在 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 之类的构造中使用时，会生成一个 SQL 函数显示，通常由一个名称、一对括号（虽然不总是如此）和可能一些参数组成。典型的 SQL 函数示例如下：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">count()</span></code> 函数，一个聚合函数，用于计算返回的行数：</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">())</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lower()</span></code> 函数，一个字符串函数，用于将字符串转换为小写：</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="s2">&quot;A String With Much UPPERCASE&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">lower</span><span class="p">(:</span><span class="n">lower_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">lower_1</span>
</div></pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">now()</span></code> 函数，提供当前日期和时间；由于这是一个常见函数，SQLAlchemy 知道如何为每个后端以不同方式呈现，在 SQLite 的情况下使用 CURRENT_TIMESTAMP 函数：</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">now_1</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="p">[(</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">(...),)]</span>
<span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>由于大多数数据库后端具有数十甚至数百种不同的 SQL 函数，<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> 尽可能宽松地接受任何从该命名空间访问的名称都被自动视为一个 SQL 函数，这些函数将以通用方式呈现:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">17</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">some_crazy_function_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">some_crazy_function_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>同时，一小部分极为常见的 SQL 函数如 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a> 包含预打包版本，提供适当的类型信息，并在某些情况下生成特定于后端的 SQL。下面的示例对比了 PostgreSQL 方言和 Oracle 数据库方言的 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a> 函数的 SQL 生成：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<span class="go">{printsql}SELECT now() AS now_1{stop}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<span class="go">{printsql}SELECT CURRENT_TIMESTAMP AS now_1 FROM DUAL{stop}</span></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--24-input--2" name="tab-set--24" type="radio"><label class="tab-label" for="tab-set--24-input--2">英文</label><div class="tab-content docutils container">
<p>First introduced earlier in this section at
<a class="reference internal" href="#tutorial-group-by-w-aggregates"><span class="std std-ref">使用 GROUP BY / HAVING 的聚合函数</span></a>, the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> object serves as a
factory for creating new <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> objects, which when used
in a construct like <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a>, produce a SQL function display,
typically consisting of a name, some parenthesis (although not always), and
possibly some arguments. Examples of typical SQL functions include:</p>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">count()</span></code> function, an aggregate function which counts how many rows are returned:</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">())</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">user_table</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">count_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">lower()</span></code> function, a string function that converts a string to lower case:</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="s2">&quot;A String With Much UPPERCASE&quot;</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">lower</span><span class="p">(:</span><span class="n">lower_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">lower_1</span>
</div></pre></div>
</div>
<ul class="simple">
<li><p>the <code class="docutils literal notranslate"><span class="pre">now()</span></code> function, which provides for the current date and time; as this is a common function, SQLAlchemy knows how to render this differently for each backend, in the case of SQLite using the CURRENT_TIMESTAMP function:</p></li>
</ul>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">now_1</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="p">[(</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">(...),)]</span>
<span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>As most database backends feature dozens if not hundreds of different SQL
functions, <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> tries to be as liberal as possible in what it
accepts. Any name that is accessed from this namespace is automatically
considered to be a SQL function that will render in a generic way:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">17</span><span class="p">)))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">some_crazy_function</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">:</span><span class="n">some_crazy_function_2</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">some_crazy_function_1</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
</div></pre></div>
</div>
<p>At the same time, a relatively small set of extremely common SQL functions such
as <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a>, <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a>, <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a>,
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a> include pre-packaged versions of themselves which
provide for proper typing information as well as backend-specific SQL
generation in some cases.  The example below contrasts the SQL generation that
occurs for the PostgreSQL dialect compared to the Oracle Database dialect for
the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a> function:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">postgresql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">postgresql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">now_1</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">now_1</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">DUAL</span>
</div></pre></div>
</div>
</div>
</div>
<section id="id9">
<h3>函数具有返回类型<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h3>
<p>Functions Have Return Types</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--25-input--1" name="tab-set--25" type="radio"><label class="tab-label" for="tab-set--25-input--1">中文</label><div class="tab-content docutils container">
<p>函数是列表达式，因此它们也具有描述生成的 SQL 表达式的数据类型的 SQL <a class="reference internal" href="../core/types.html#types-toplevel"><span class="std std-ref">数据类型</span></a>。我们在这里将这些类型称为“SQL 返回类型”，指的是函数在数据库端 SQL 表达式上下文中返回的 SQL 值的类型，而不是 Python 函数的“返回类型”。</p>
<p>可以通过引用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Function.type</span></code> 属性来访问任何 SQL 函数的 SQL 返回类型，通常用于调试目的；对于一些非常常见的 SQL 函数，此属性将预先配置，但对于大多数 SQL 函数，如果未另行指定，则为“null”数据类型:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 预先配置的 SQL 函数（只有几十个）</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 任意 SQL 函数（所有其他 SQL 函数）</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">run_some_calculation</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<p>当在更大的表达式上下文中使用函数表达式时，这些 SQL 返回类型是重要的；也就是说，当表达式的数据类型是 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> 或 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a> 时，数学运算符将工作得更好，JSON 访问器需要使用 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 类型才能工作。某些类别的函数返回整个行而不是列值，需要引用特定列；这些函数称为 <a class="reference internal" href="#tutorial-functions-table-valued"><span class="std std-ref">表值函数</span></a>。</p>
<p>在执行语句并获取行时，函数的 SQL 返回类型也可能很重要，对于这些情况，SQLAlchemy 必须应用结果集处理。一个典型的例子是 SQLite 上的日期相关函数，其中 SQLAlchemy 的 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> 和相关数据类型在接收结果行时负责从字符串值转换为 Python <code class="docutils literal notranslate"><span class="pre">datetime()</span></code> 对象。</p>
<p>要将特定类型应用于我们正在创建的函数，我们使用 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function.params.type_" title="sqlalchemy.sql.functions.Function"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Function.type_</span></code></a> 参数传递它；类型参数可以是 <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> 类或实例。在下面的示例中，我们传递 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 类以生成 PostgreSQL <code class="docutils literal notranslate"><span class="pre">json_object()</span></code> 函数，注意到 SQL 返回类型将是 JSON 类型:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function_expr</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_object</span><span class="p">(</span><span class="s1">&#39;{a, 1, b, &quot;def&quot;, c, 3.5}&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
<p>通过使用 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 数据类型创建我们的 JSON 函数，SQL 表达式对象具有 JSON 相关功能，例如访问元素:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">function_expr</span><span class="p">[</span><span class="s2">&quot;def&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">json_object</span><span class="p">(:</span><span class="n">json_object_1</span><span class="p">)[:</span><span class="n">json_object_2</span><span class="p">]</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--25-input--2" name="tab-set--25" type="radio"><label class="tab-label" for="tab-set--25-input--2">英文</label><div class="tab-content docutils container">
<p>As functions are column expressions, they also have
SQL <a class="reference internal" href="../core/types.html#types-toplevel"><span class="std std-ref">datatypes</span></a> that describe the data type of
a generated SQL expression.  We refer to these types here as “SQL return types”,
in reference to the type of SQL value that is returned by the function
in the context of a database-side SQL expression,
as opposed to the “return type” of a Python function.</p>
<p>The SQL return type of any SQL function may be accessed, typically for
debugging purposes, by referring to the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Function.type</span></code>
attribute; this will be pre-configured for a <strong>select few</strong> of extremely
common SQL functions, but for most SQL functions is the “null” datatype
if not otherwise specified:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># pre-configured SQL function (only a few dozen of these)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># arbitrary SQL function (all other SQL functions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">run_some_calculation</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<p>These SQL return types are significant when making
use of the function expression in the context of a larger expression; that is,
math operators will work better when the datatype of the expression is
something like <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> or <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Numeric" title="sqlalchemy.types.Numeric"><code class="xref py py-class docutils literal notranslate"><span class="pre">Numeric</span></code></a>, JSON
accessors in order to work need to be using a type such as
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>.  Certain classes of functions return entire rows
instead of column values, where there is a need to refer to specific columns;
such functions are known
as <a class="reference internal" href="#tutorial-functions-table-valued"><span class="std std-ref">table valued functions</span></a>.</p>
<p>The SQL return type of the function may also be significant when executing a
statement and getting rows back, for those cases where SQLAlchemy has to apply
result-set processing. A prime example of this are date-related functions on
SQLite, where SQLAlchemy’s <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a> and related datatypes take
on the role of converting from string values to Python <code class="docutils literal notranslate"><span class="pre">datetime()</span></code> objects
as result rows are received.</p>
<p>To apply a specific type to a function we’re creating, we pass it using the
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function.params.type_" title="sqlalchemy.sql.functions.Function"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Function.type_</span></code></a> parameter; the type argument may be
either a <a class="reference internal" href="../core/type_api.html#sqlalchemy.types.TypeEngine" title="sqlalchemy.types.TypeEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeEngine</span></code></a> class or an instance.  In the example
below we pass the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> class to generate the PostgreSQL
<code class="docutils literal notranslate"><span class="pre">json_object()</span></code> function, noting that the SQL return type will be of
type JSON:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function_expr</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_object</span><span class="p">(</span><span class="s1">&#39;{a, 1, b, &quot;def&quot;, c, 3.5}&#39;</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">JSON</span><span class="p">)</span></pre></div>
</div>
<p>By creating our JSON function with the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> datatype, the
SQL expression object takes on JSON-related features, such as that of accessing
elements:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">function_expr</span><span class="p">[</span><span class="s2">&quot;def&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">json_object</span><span class="p">(:</span><span class="n">json_object_1</span><span class="p">)[:</span><span class="n">json_object_2</span><span class="p">]</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
</div>
</div>
</section>
<section id="id10">
<h3>内置函数具有预配置的返回类型<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>Built-in Functions Have Pre-Configured Return Types</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--26-input--1" name="tab-set--26" type="radio"><label class="tab-label" for="tab-set--26-input--1">中文</label><div class="tab-content docutils container">
<p>对于常见的聚合函数如 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.min" title="sqlalchemy.sql.functions.min"><code class="xref py py-class docutils literal notranslate"><span class="pre">min</span></code></a> 以及少量日期函数如 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a> 和字符串函数如 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a>，SQL 返回类型已适当设置，有时基于使用情况。<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a> 函数和类似的聚合过滤函数将根据给定的参数设置 SQL 返回类型:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_int&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">type</span>
<span class="go">Integer()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_str&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>日期和时间函数通常对应于由 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>、<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Date" title="sqlalchemy.types.Date"><code class="xref py py-class docutils literal notranslate"><span class="pre">Date</span></code></a> 或 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Time" title="sqlalchemy.types.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">Time</span></code></a> 描述的 SQL 表达式:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">current_date</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">Date()</span></pre></div>
</div>
<p>已知的字符串函数如 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a> 会知道 SQL 表达式的类型为 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>然而，对于绝大多数 SQL 函数，SQLAlchemy 并未在其非常小的已知函数列表中明确列出。例如，虽然通常没有问题使用 SQL 函数 <code class="docutils literal notranslate"><span class="pre">func.lower()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">func.upper()</span></code> 转换字符串的大小写，但 SQLAlchemy 实际上并不知道这些函数，因此它们具有“null” SQL 返回类型:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s2">&quot;lowercase&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<p>对于简单的函数如 <code class="docutils literal notranslate"><span class="pre">upper</span></code> 和 <code class="docutils literal notranslate"><span class="pre">lower</span></code>，这个问题通常并不显著，因为字符串值可以从数据库中接收而无需 SQLAlchemy 端的任何特殊类型处理，SQLAlchemy 的类型转换规则通常也能正确猜测意图；例如，Python 的 <code class="docutils literal notranslate"><span class="pre">+</span></code> 运算符将根据表达式两边的内容正确解释为字符串连接运算符:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s2">&quot;lowercase&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; suffix&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">upper</span><span class="p">(:</span><span class="n">upper_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">:</span><span class="n">upper_2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>总体而言，可能需要 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function.params.type_" title="sqlalchemy.sql.functions.Function"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Function.type_</span></code></a> 参数的情景是：</p>
<ol class="arabic">
<li><p>该函数不是 SQLAlchemy 内置函数；这一点可以通过创建该函数并观察 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Function.type</span></code> 属性来证明，即:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">Integer()</span></pre></div>
</div>
</li>
</ol>
<p>vs.:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">json_object</span><span class="p">(</span><span class="s1">&#39;{&quot;a&quot;, &quot;b&quot;}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>需要函数感知的表达式支持；这通常指与数据类型如 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 或 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a> 相关的特殊运算符</p></li>
<li><p>需要结果值处理，这可能包括类型如 <code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code>、<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code></a>、<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>，或再次是特殊数据类型如 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>、<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>。</p></li>
</ol>
</div>
<input class="tab-input" id="tab-set--26-input--2" name="tab-set--26" type="radio"><label class="tab-label" for="tab-set--26-input--2">英文</label><div class="tab-content docutils container">
<p>For common aggregate functions like <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.count" title="sqlalchemy.sql.functions.count"><code class="xref py py-class docutils literal notranslate"><span class="pre">count</span></code></a>,
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a>, <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.min" title="sqlalchemy.sql.functions.min"><code class="xref py py-class docutils literal notranslate"><span class="pre">min</span></code></a> as well as a very small number
of date functions like <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.now" title="sqlalchemy.sql.functions.now"><code class="xref py py-class docutils literal notranslate"><span class="pre">now</span></code></a> and string functions like
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a>, the SQL return type is set up appropriately,
sometimes based on usage. The <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.max" title="sqlalchemy.sql.functions.max"><code class="xref py py-class docutils literal notranslate"><span class="pre">max</span></code></a> function and similar
aggregate filtering functions will set up the SQL return type based on the
argument given:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_int&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m1</span><span class="o">.</span><span class="n">type</span>
<span class="go">Integer()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="s2">&quot;some_str&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>Date and time functions typically correspond to SQL expressions described by
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.DateTime" title="sqlalchemy.types.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Date" title="sqlalchemy.types.Date"><code class="xref py py-class docutils literal notranslate"><span class="pre">Date</span></code></a> or <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Time" title="sqlalchemy.types.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">Time</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">DateTime()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">current_date</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">Date()</span></pre></div>
</div>
<p>A known string function such as <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.concat" title="sqlalchemy.sql.functions.concat"><code class="xref py py-class docutils literal notranslate"><span class="pre">concat</span></code></a>
will know that a SQL expression would be of type <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">String()</span></pre></div>
</div>
<p>However, for the vast majority of SQL functions, SQLAlchemy does not have them
explicitly present in its very small list of known functions.  For example,
while there is typically no issue using SQL functions <code class="docutils literal notranslate"><span class="pre">func.lower()</span></code>
and <code class="docutils literal notranslate"><span class="pre">func.upper()</span></code> to convert the casing of strings, SQLAlchemy doesn’t
actually know about these functions, so they have a “null” SQL return type:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s2">&quot;lowercase&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<p>For simple functions like <code class="docutils literal notranslate"><span class="pre">upper</span></code> and <code class="docutils literal notranslate"><span class="pre">lower</span></code>, the issue is not usually
significant, as string values may be received from the database without any
special type handling on the SQLAlchemy side, and SQLAlchemy’s type
coercion rules can often correctly guess intent as well; the Python <code class="docutils literal notranslate"><span class="pre">+</span></code>
operator for example will be correctly interpreted as the string concatenation
operator based on looking at both sides of the expression:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="s2">&quot;lowercase&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; suffix&quot;</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="k">upper</span><span class="p">(:</span><span class="n">upper_1</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">:</span><span class="n">upper_2</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>Overall, the scenario where the
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function.params.type_" title="sqlalchemy.sql.functions.Function"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Function.type_</span></code></a> parameter is likely necessary is:</p>
<p>1. the function is not already a SQLAlchemy built-in function; this can be
evidenced by creating the function and observing the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Function.type</span></code>
attribute, that is:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">type</span>
<span class="go">Integer()</span></pre></div>
</div>
<p>vs.:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">json_object</span><span class="p">(</span><span class="s1">&#39;{&quot;a&quot;, &quot;b&quot;}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">type</span>
<span class="go">NullType()</span></pre></div>
</div>
<p>2. Function-aware expression support is needed; this most typically refers to
special operators related to datatypes such as <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> or
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a></p>
<p>3. Result value processing is needed, which may include types such as
<code class="xref py py-class docutils literal notranslate"><span class="pre">DateTime</span></code>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Boolean" title="sqlalchemy.types.Boolean"><code class="xref py py-class docutils literal notranslate"><span class="pre">Boolean</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Enum" title="sqlalchemy.types.Enum"><code class="xref py py-class docutils literal notranslate"><span class="pre">Enum</span></code></a>,
or again special datatypes such as <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>,
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.ARRAY" title="sqlalchemy.types.ARRAY"><code class="xref py py-class docutils literal notranslate"><span class="pre">ARRAY</span></code></a>.</p>
</div>
</div>
</section>
<section id="id11">
<h3>高级 SQL 函数技术<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h3>
<p>Advanced SQL Function Techniques</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--27-input--1" name="tab-set--27" type="radio"><label class="tab-label" for="tab-set--27-input--1">中文</label><div class="tab-content docutils container">
<p>以下小节说明了更多可以用 SQL 函数完成的操作。虽然这些技术比基本的 SQL 函数使用更不常见且更高级，但它们仍然非常流行，主要是因为 PostgreSQL 强调更复杂的函数形式，包括表值和列值形式，这些形式在 JSON 数据中很受欢迎。</p>
</div>
<input class="tab-input" id="tab-set--27-input--2" name="tab-set--27" type="radio"><label class="tab-label" for="tab-set--27-input--2">英文</label><div class="tab-content docutils container">
<p>The following subsections illustrate more things that can be done with
SQL functions.  While these techniques are less common and more advanced than
basic SQL function use, they nonetheless are extremely popular, largely
as a result of PostgreSQL’s emphasis on more complex function forms, including
table- and column-valued forms that are popular with JSON data.</p>
</div>
</div>
<section id="tutorial-window-functions">
<span id="id12"></span><h4>使用窗口函数<a class="headerlink" href="#tutorial-window-functions" title="Link to this heading">¶</a></h4>
<p>Using Window Functions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--28-input--1" name="tab-set--28" type="radio"><label class="tab-label" for="tab-set--28-input--1">中文</label><div class="tab-content docutils container">
<p>窗口函数是 SQL 聚合函数的一种特殊用法，它在处理各个结果行时计算在一个组内返回的行的聚合值。与 <code class="docutils literal notranslate"><span class="pre">MAX()</span></code> 这样的函数不同，后者会给出一组行中某列的最大值，而作为“窗口函数”使用的同一函数将为每一行提供 <em>该行</em> 的最大值。</p>
<p>在 SQL 中，窗口函数允许指定应用函数的行，“分区”值考虑不同子集的窗口，以及“order by”表达式，重要的是它指示应用聚合函数的行顺序。</p>
<p>在 SQLAlchemy 中，由 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> 命名空间生成的所有 SQL 函数都包含一个方法 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a>，该方法授予窗口函数或“OVER”语法；生成的构造是 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Over" title="sqlalchemy.sql.expression.Over"><code class="xref py py-class docutils literal notranslate"><span class="pre">Over</span></code></a> 构造。</p>
<p>一个常用的窗口函数是 <code class="docutils literal notranslate"><span class="pre">row_number()</span></code> 函数，它简单地对行进行计数。我们可以将此行计数分区到用户名，以对各个用户的电子邮件地址进行编号：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.row_number().over(partition_by=user_table.c.name),</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">row_number</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(1, &#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;), (2, &#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (1, &#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql_print'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>上面，<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.partition_by</span></code></a> 参数用于在 OVER 子句中呈现 <code class="docutils literal notranslate"><span class="pre">PARTITION</span> <span class="pre">BY</span></code> 子句。我们还可以使用 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.order_by</span></code></a> 使用 <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> 子句：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count().over(order_by=user_table.c.name),</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(2, &#39;sandy&#39;, &#39;sandy@sql.org&#39;), (2, &#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (3, &#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql_print'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>窗口函数的更多选项包括范围的使用；有关更多示例，请参见 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.over" title="sqlalchemy.sql.expression.over"><code class="xref py py-func docutils literal notranslate"><span class="pre">over()</span></code></a>。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>重要的是要注意 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a> 方法仅适用于实际是聚合函数的 SQL 函数；虽然 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Over" title="sqlalchemy.sql.expression.Over"><code class="xref py py-class docutils literal notranslate"><span class="pre">Over</span></code></a> 构造将愉快地为给定的任何 SQL 函数呈现自己，但如果函数本身不是 SQL 聚合函数，数据库将拒绝该表达式。</p>
</div>
</div>
<input class="tab-input" id="tab-set--28-input--2" name="tab-set--28" type="radio"><label class="tab-label" for="tab-set--28-input--2">英文</label><div class="tab-content docutils container">
<p>A window function is a special use of a SQL aggregate function which calculates
the aggregate value over the rows being returned in a group as the individual
result rows are processed.  Whereas a function like <code class="docutils literal notranslate"><span class="pre">MAX()</span></code> will give you
the highest value of a column within a set of rows, using the same function
as a “window function” will given you the highest value for each row,
<em>as of that row</em>.</p>
<p>In SQL, window functions allow one to specify the rows over which the
function should be applied, a “partition” value which considers the window
over different sub-sets of rows, and an “order by” expression which importantly
indicates the order in which rows should be applied to the aggregate function.</p>
<p>In SQLAlchemy, all SQL functions generated by the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> namespace
include a method <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a> which
grants the window function, or “OVER”, syntax; the construct produced
is the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Over" title="sqlalchemy.sql.expression.Over"><code class="xref py py-class docutils literal notranslate"><span class="pre">Over</span></code></a> construct.</p>
<p>A common function used with window functions is the <code class="docutils literal notranslate"><span class="pre">row_number()</span></code> function
which simply counts rows. We may partition this row count against user name to
number the email addresses of individual users:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.row_number().over(partition_by=user_table.c.name),</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">row_number</span><span class="p">()</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(1, &#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;), (2, &#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (1, &#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql_print'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>Above, the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.partition_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.partition_by</span></code></a> parameter
is used so that the <code class="docutils literal notranslate"><span class="pre">PARTITION</span> <span class="pre">BY</span></code> clause is rendered within the OVER clause.
We also may make use of the <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> clause using <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over.params.order_by" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">FunctionElement.over.order_by</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count().over(order_by=user_table.c.name),</span>
<span class="go">...         user_table.c.name,</span>
<span class="go">...         address_table.c.email_address,</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">OVER</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(2, &#39;sandy&#39;, &#39;sandy@sqlalchemy.org&#39;), (2, &#39;sandy&#39;, &#39;sandy@squirrelpower.org&#39;), (3, &#39;spongebob&#39;, &#39;spongebob@sqlalchemy.org&#39;)]</span>
<div class='show_sql_print'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>Further options for window functions include usage of ranges; see
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.over" title="sqlalchemy.sql.expression.over"><code class="xref py py-func docutils literal notranslate"><span class="pre">over()</span></code></a> for more examples.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>It’s important to note that the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.over" title="sqlalchemy.sql.functions.FunctionElement.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.over()</span></code></a>
method only applies to those SQL functions which are in fact aggregate
functions; while the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.Over" title="sqlalchemy.sql.expression.Over"><code class="xref py py-class docutils literal notranslate"><span class="pre">Over</span></code></a> construct will happily render itself
for any SQL function given, the database will reject the expression if the
function itself is not a SQL aggregate function.</p>
</div>
</div>
</div>
</section>
<section id="within-groupfilter">
<span id="tutorial-functions-within-group"></span><h4>特殊修饰符 WITHIN GROUP、FILTER<a class="headerlink" href="#within-groupfilter" title="Link to this heading">¶</a></h4>
<p>Special Modifiers WITHIN GROUP, FILTER</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--29-input--1" name="tab-set--29" type="radio"><label class="tab-label" for="tab-set--29-input--1">中文</label><div class="tab-content docutils container">
<p>“WITHIN GROUP” SQL 语法与“有序集合”或“假设集合”聚合函数结合使用。常见的“有序集合”函数包括 <code class="docutils literal notranslate"><span class="pre">percentile_cont()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rank()</span></code>。SQLAlchemy 包括内置实现 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.rank" title="sqlalchemy.sql.functions.rank"><code class="xref py py-class docutils literal notranslate"><span class="pre">rank</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.dense_rank" title="sqlalchemy.sql.functions.dense_rank"><code class="xref py py-class docutils literal notranslate"><span class="pre">dense_rank</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.mode" title="sqlalchemy.sql.functions.mode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mode</span></code></a>、<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.percentile_cont" title="sqlalchemy.sql.functions.percentile_cont"><code class="xref py py-class docutils literal notranslate"><span class="pre">percentile_cont</span></code></a> 和 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.percentile_disc" title="sqlalchemy.sql.functions.percentile_disc"><code class="xref py py-class docutils literal notranslate"><span class="pre">percentile_disc</span></code></a>，这些实现包括 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group" title="sqlalchemy.sql.functions.FunctionElement.within_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.within_group()</span></code></a> 方法:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     func.unnest(</span>
<span class="go">...         func.percentile_disc([0.25, 0.5, 0.75, 1]).within_group(user_table.c.name)</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">unnest</span><span class="p">(</span><span class="n">percentile_disc</span><span class="p">(:</span><span class="n">percentile_disc_1</span><span class="p">)</span><span class="w"> </span><span class="n">WITHIN</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
</div></pre></div>
</div>
<p>某些后端支持“FILTER”，与返回的总行范围相比，限制聚合函数的范围到特定子集行，可使用 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter" title="sqlalchemy.sql.functions.FunctionElement.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.filter()</span></code></a> 方法获得:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.email_address).filter(user_table.c.name == &quot;sandy&quot;),</span>
<span class="go">...         func.count(address_table.c.email_address).filter(</span>
<span class="go">...             user_table.c.name == &quot;spongebob&quot;</span>
<span class="go">...         ),</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(2, 1)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--29-input--2" name="tab-set--29" type="radio"><label class="tab-label" for="tab-set--29-input--2">英文</label><div class="tab-content docutils container">
<p>The “WITHIN GROUP” SQL syntax is used in conjunction with an “ordered set”
or a “hypothetical set” aggregate
function.  Common “ordered set” functions include <code class="docutils literal notranslate"><span class="pre">percentile_cont()</span></code>
and <code class="docutils literal notranslate"><span class="pre">rank()</span></code>.  SQLAlchemy includes built in implementations
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.rank" title="sqlalchemy.sql.functions.rank"><code class="xref py py-class docutils literal notranslate"><span class="pre">rank</span></code></a>, <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.dense_rank" title="sqlalchemy.sql.functions.dense_rank"><code class="xref py py-class docutils literal notranslate"><span class="pre">dense_rank</span></code></a>,
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.mode" title="sqlalchemy.sql.functions.mode"><code class="xref py py-class docutils literal notranslate"><span class="pre">mode</span></code></a>, <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.percentile_cont" title="sqlalchemy.sql.functions.percentile_cont"><code class="xref py py-class docutils literal notranslate"><span class="pre">percentile_cont</span></code></a> and
<a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.percentile_disc" title="sqlalchemy.sql.functions.percentile_disc"><code class="xref py py-class docutils literal notranslate"><span class="pre">percentile_disc</span></code></a> which include a <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group" title="sqlalchemy.sql.functions.FunctionElement.within_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.within_group()</span></code></a>
method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span>
<span class="go">...     func.unnest(</span>
<span class="go">...         func.percentile_disc([0.25, 0.5, 0.75, 1]).within_group(user_table.c.name)</span>
<span class="go">...     )</span>
<span class="go">... )</span>
<div class='show_sql_print'><span class="k">unnest</span><span class="p">(</span><span class="n">percentile_disc</span><span class="p">(:</span><span class="n">percentile_disc_1</span><span class="p">)</span><span class="w"> </span><span class="n">WITHIN</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="p">(</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
</div></pre></div>
</div>
<p>“FILTER” is supported by some backends to limit the range of an aggregate function to a
particular subset of rows compared to the total range of rows returned, available
using the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter" title="sqlalchemy.sql.functions.FunctionElement.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.filter()</span></code></a> method:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(</span>
<span class="go">...         func.count(address_table.c.email_address).filter(user_table.c.name == &quot;sandy&quot;),</span>
<span class="go">...         func.count(address_table.c.email_address).filter(</span>
<span class="go">...             user_table.c.name == &quot;spongebob&quot;</span>
<span class="go">...         ),</span>
<span class="go">...     )</span>
<span class="go">...     .select_from(user_table)</span>
<span class="go">...     .join(address_table)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>  
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     print(result.all())</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span><span class="p">,</span>
<span class="k">count</span><span class="p">(</span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">)</span><span class="w"> </span><span class="n">FILTER</span><span class="w"> </span><span class="p">(</span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;sandy&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;spongebob&#39;</span><span class="p">)</span>
</div><span class="go">[(2, 1)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
</div>
</div>
</section>
<section id="tutorial-functions-table-valued">
<span id="id13"></span><h4>表值函数<a class="headerlink" href="#tutorial-functions-table-valued" title="Link to this heading">¶</a></h4>
<p>Table-Valued Functions</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--30-input--1" name="tab-set--30" type="radio"><label class="tab-label" for="tab-set--30-input--1">中文</label><div class="tab-content docutils container">
<p>表值 SQL 函数支持包含命名子元素的标量表示。通常用于 JSON 和 ARRAY 相关函数以及诸如 <code class="docutils literal notranslate"><span class="pre">generate_series()</span></code> 之类的函数，表值函数在 FROM 子句中指定，然后作为表或有时甚至作为列引用。这种形式的函数在 PostgreSQL 数据库中很突出，但 SQLite、Oracle 数据库和 SQL Server 也支持某些形式的表值函数。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued-overview"><span class="std std-ref">Table values, Table and Column valued functions, Row and Tuple objects</span></a> - 在 <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> 文档中。</p>
<p>尽管许多数据库支持表值和其他特殊形式，但 PostgreSQL 是对这些功能需求最大的地方。请参阅本节，了解 PostgreSQL 语法的其他示例以及其他功能。</p>
</div>
<p>SQLAlchemy 提供了 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued" title="sqlalchemy.sql.functions.FunctionElement.table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.table_valued()</span></code></a> 方法作为基本的“表值函数”构造，它将 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> 对象转换为包含一系列命名列的 FROM 子句，基于位置传递的字符串名称。它返回一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias" title="sqlalchemy.sql.expression.TableValuedAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableValuedAlias</span></code></a> 对象，这是一个功能启用的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> 构造，可以像 <a class="reference internal" href="#tutorial-using-aliases"><span class="std std-ref">使用别名</span></a> 中介绍的任何其他 FROM 子句一样使用。下面我们说明了 <code class="docutils literal notranslate"><span class="pre">json_each()</span></code> 函数，尽管它在 PostgreSQL 上很常见，但现代版本的 SQLite 也支持:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">onetwothree</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_each</span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">table_valued</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">onetwothree</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onetwothree</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     result.all()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">json_each</span><span class="p">(</span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;two&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;three&#39;</span><span class="p">)</span>
</div><span class="go">[(&#39;two&#39;,), (&#39;three&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>上面，我们使用了 SQLite 和 PostgreSQL 支持的 <code class="docutils literal notranslate"><span class="pre">json_each()</span></code> JSON 函数生成一个包含单列的表值表达式，该列称为 <code class="docutils literal notranslate"><span class="pre">value</span></code>，然后选择了它的三行中的两行。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued"><span class="std std-ref">Table-Valued Functions</span></a> - 在 <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> 文档中 -
本节将详细介绍其他语法，例如特殊列推导和已知在 PostgreSQL 上有效的“WITH ORDINALITY”。</p>
</div>
</div>
<input class="tab-input" id="tab-set--30-input--2" name="tab-set--30" type="radio"><label class="tab-label" for="tab-set--30-input--2">英文</label><div class="tab-content docutils container">
<p>Table-valued SQL functions support a scalar representation that contains named
sub-elements. Often used for JSON and ARRAY-oriented functions as well as
functions like <code class="docutils literal notranslate"><span class="pre">generate_series()</span></code>, the table-valued function is specified in
the FROM clause, and is then referenced as a table, or sometimes even as a
column. Functions of this form are prominent within the PostgreSQL database,
however some forms of table valued functions are also supported by SQLite,
Oracle Database, and SQL Server.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued-overview"><span class="std std-ref">Table values, Table and Column valued functions, Row and Tuple objects</span></a> - in the <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> documentation.</p>
<p>While many databases support table valued and other special
forms, PostgreSQL tends to be where there is the most demand for these
features.   See this section for additional examples of PostgreSQL
syntaxes as well as additional features.</p>
</div>
<p>SQLAlchemy provides the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued" title="sqlalchemy.sql.functions.FunctionElement.table_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.table_valued()</span></code></a> method
as the basic “table valued function” construct, which will convert a
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.func" title="sqlalchemy.sql.expression.func"><code class="xref py py-data docutils literal notranslate"><span class="pre">func</span></code></a> object into a FROM clause containing a series of named
columns, based on string names passed positionally. This returns a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias" title="sqlalchemy.sql.expression.TableValuedAlias"><code class="xref py py-class docutils literal notranslate"><span class="pre">TableValuedAlias</span></code></a> object, which is a function-enabled
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Alias" title="sqlalchemy.sql.expression.Alias"><code class="xref py py-class docutils literal notranslate"><span class="pre">Alias</span></code></a> construct that may be used as any other FROM clause as
introduced at <a class="reference internal" href="#tutorial-using-aliases"><span class="std std-ref">使用别名</span></a>. Below we illustrate the
<code class="docutils literal notranslate"><span class="pre">json_each()</span></code> function, which while common on PostgreSQL is also supported by
modern versions of SQLite:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">onetwothree</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">json_each</span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">table_valued</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">onetwothree</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">onetwothree</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">in_</span><span class="p">([</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     result.all()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">json_each</span><span class="p">(</span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">anon_1</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;two&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;three&#39;</span><span class="p">)</span>
</div><span class="go">[(&#39;two&#39;,), (&#39;three&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>Above, we used the <code class="docutils literal notranslate"><span class="pre">json_each()</span></code> JSON function supported by SQLite and
PostgreSQL to generate a table valued expression with a single column referred
towards as <code class="docutils literal notranslate"><span class="pre">value</span></code>, and then selected two of its three rows.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-table-valued"><span class="std std-ref">Table-Valued Functions</span></a> - in the <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> documentation -
this section will detail additional syntaxes such as special column derivations
and “WITH ORDINALITY” that are known to work with PostgreSQL.</p>
</div>
</div>
</div>
</section>
<section id="tutorial-functions-column-valued">
<span id="id14"></span><h4>列值函数 - 表值函数作为标量列<a class="headerlink" href="#tutorial-functions-column-valued" title="Link to this heading">¶</a></h4>
<p>Column Valued Functions - Table Valued Function as a Scalar Column</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--31-input--1" name="tab-set--31" type="radio"><label class="tab-label" for="tab-set--31-input--1">中文</label><div class="tab-content docutils container">
<p>PostgreSQL 和 Oracle 数据库支持的一种特殊语法是指在 FROM 子句中引用一个函数，然后在 SELECT 语句或其他列表达式上下文的列子句中将其作为单列交付。PostgreSQL 对这种语法的广泛使用包括 <code class="docutils literal notranslate"><span class="pre">json_array_elements()</span></code>、<code class="docutils literal notranslate"><span class="pre">json_object_keys()</span></code>、<code class="docutils literal notranslate"><span class="pre">json_each_text()</span></code>、<code class="docutils literal notranslate"><span class="pre">json_each()</span></code> 等函数。</p>
<p>SQLAlchemy 将这种语法称为“列值”函数，可以通过将 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued" title="sqlalchemy.sql.functions.FunctionElement.column_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.column_valued()</span></code></a> 修饰符应用于 <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> 构造来实现:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">json_array_elements</span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">column_valued</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">x</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">json_array_elements</span><span class="p">(:</span><span class="n">json_array_elements_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">x</span>
</div></pre></div>
</div>
<p>“列值”形式也受到 Oracle 数据库方言的支持，可用于自定义 SQL 函数:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">scalar_strings</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">column_valued</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">COLUMN_VALUE</span>
<span class="k">FROM</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="p">(</span><span class="n">scalar_strings</span><span class="p">(:</span><span class="n">scalar_strings_1</span><span class="p">))</span><span class="w"> </span><span class="n">s</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-column-valued"><span class="std std-ref">Column Valued Functions</span></a> - 在 <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> 文档中。</p>
</div>
</div>
<input class="tab-input" id="tab-set--31-input--2" name="tab-set--31" type="radio"><label class="tab-label" for="tab-set--31-input--2">英文</label><div class="tab-content docutils container">
<p>A special syntax supported by PostgreSQL and Oracle Database is that of
referring towards a function in the FROM clause, which then delivers itself as
a single column in the columns clause of a SELECT statement or other column
expression context.  PostgreSQL makes great use of this syntax for such
functions as <code class="docutils literal notranslate"><span class="pre">json_array_elements()</span></code>, <code class="docutils literal notranslate"><span class="pre">json_object_keys()</span></code>,
<code class="docutils literal notranslate"><span class="pre">json_each_text()</span></code>, <code class="docutils literal notranslate"><span class="pre">json_each()</span></code>, etc.</p>
<p>SQLAlchemy refers to this as a “column valued” function and is available
by applying the <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued" title="sqlalchemy.sql.functions.FunctionElement.column_valued"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FunctionElement.column_valued()</span></code></a> modifier
to a <a class="reference internal" href="../core/functions.html#sqlalchemy.sql.functions.Function" title="sqlalchemy.sql.functions.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a> construct:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">select</span><span class="p">,</span> <span class="n">func</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">json_array_elements</span><span class="p">(</span><span class="s1">&#39;[&quot;one&quot;, &quot;two&quot;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">column_valued</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">x</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">json_array_elements</span><span class="p">(:</span><span class="n">json_array_elements_1</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">x</span>
</div></pre></div>
</div>
<p>The “column valued” form is also supported by the Oracle Database dialects,
where it is usable for custom SQL functions:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">oracle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">scalar_strings</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">column_valued</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">oracle</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">COLUMN_VALUE</span>
<span class="k">FROM</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="p">(</span><span class="n">scalar_strings</span><span class="p">(:</span><span class="n">scalar_strings_1</span><span class="p">))</span><span class="w"> </span><span class="n">s</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../dialects/postgresql.html#postgresql-column-valued"><span class="std std-ref">Column Valued Functions</span></a> - in the <a class="reference internal" href="../dialects/postgresql.html#postgresql-toplevel"><span class="std std-ref">PostgreSQL</span></a> documentation.</p>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="tutorial-casts">
<span id="id15"></span><h2>数据强制转换和类型强制转换<a class="headerlink" href="#tutorial-casts" title="Link to this heading">¶</a></h2>
<p>Data Casts and Type Coercion</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--32-input--1" name="tab-set--32" type="radio"><label class="tab-label" for="tab-set--32-input--1">中文</label><div class="tab-content docutils container">
<p>在 SQL 中，我们经常需要显式地指示表达式的数据类型，或者告诉数据库在一个模糊的表达式中预期的数据类型，或者在某些情况下，我们想将 SQL 表达式的隐含数据类型转换为其他类型。SQL CAST 关键字用于此任务，在 SQLAlchemy 中由 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数提供。此函数接受列表达式和数据类型对象作为参数，如下所示，我们从 <code class="docutils literal notranslate"><span class="pre">user_table.c.id</span></code> 列对象生成 SQL 表达式 <code class="docutils literal notranslate"><span class="pre">CAST(user_account.id</span> <span class="pre">AS</span> <span class="pre">VARCHAR)</span></code>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     result.all()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;1&#39;,), (&#39;2&#39;,), (&#39;3&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p><a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数不仅呈现 SQL CAST 语法，还生成一个 SQLAlchemy 列表达式，该表达式在 Python 端也将作为给定的数据类型。例如，一个被 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 为 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 的字符串表达式将获得 JSON 下标和比较运算符:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;{&#39;a&#39;: &#39;b&#39;}&quot;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;a&quot;</span><span class="p">])</span>
<div class='show_sql_print'><span class="k">CAST</span><span class="p">(:</span><span class="n">param_1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">JSON</span><span class="p">)[:</span><span class="n">param_2</span><span class="p">]</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--32-input--2" name="tab-set--32" type="radio"><label class="tab-label" for="tab-set--32-input--2">英文</label><div class="tab-content docutils container">
<p>In SQL, we often need to indicate the datatype of an expression explicitly,
either to tell the database what type is expected in an otherwise ambiguous
expression, or in some cases when we want to convert the implied datatype
of a SQL expression into something else.   The SQL CAST keyword is used for
this task, which in SQLAlchemy is provided by the <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> function.
This function accepts a column expression and a data type
object as arguments, as demonstrated below where we produce a SQL expression
<code class="docutils literal notranslate"><span class="pre">CAST(user_account.id</span> <span class="pre">AS</span> <span class="pre">VARCHAR)</span></code> from the <code class="docutils literal notranslate"><span class="pre">user_table.c.id</span></code> column
object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">cast</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">String</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span> <span class="k">as</span> <span class="n">conn</span><span class="p">:</span>
<span class="go">...     result = conn.execute(stmt)</span>
<span class="go">...     result.all()</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">CAST</span><span class="p">(</span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">[(&#39;1&#39;,), (&#39;2&#39;,), (&#39;3&#39;,)]</span>
<div class='show_sql'><span class="k">ROLLBACK</span>
</div></pre></div>
</div>
<p>The <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> function not only renders the SQL CAST syntax, it also
produces a SQLAlchemy column expression that will act as the given datatype on
the Python side as well. A string expression that is <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> to
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> will gain JSON subscript and comparison operators, for example:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;{&#39;a&#39;: &#39;b&#39;}&quot;</span><span class="p">,</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;a&quot;</span><span class="p">])</span>
<div class='show_sql_print'><span class="k">CAST</span><span class="p">(:</span><span class="n">param_1</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">JSON</span><span class="p">)[:</span><span class="n">param_2</span><span class="p">]</span>
</div></pre></div>
</div>
</div>
</div>
<section id="type-coerce-python">
<h3>type_coerce() - 仅限 Python 的“强制转换”<a class="headerlink" href="#type-coerce-python" title="Link to this heading">¶</a></h3>
<p>type_coerce() - a Python-only “cast”</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--33-input--1" name="tab-set--33" type="radio"><label class="tab-label" for="tab-set--33-input--1">中文</label><div class="tab-content docutils container">
<p>有时需要让 SQLAlchemy 知道表达式的数据类型，出于上述所有原因，但不要在 SQL 端呈现 CAST 表达式，因为它可能会干扰已经可以正常工作的 SQL 操作。对于这种相当常见的用例，有另一个函数 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> 与 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 密切相关，因为它将 Python 表达式设置为具有特定的 SQL 数据库类型，但不会在数据库端呈现 <code class="docutils literal notranslate"><span class="pre">CAST</span></code> 关键字或数据类型。<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> 在处理 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> 数据类型时特别重要，因为它通常与不同平台上的字符串导向数据类型有着复杂的关系，甚至可能不是显式的数据类型，如在 SQLite 和 MariaDB 上。下面，我们使用 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> 将 Python 结构作为 JSON 字符串传递到 MySQL 的一个 JSON 函数中：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">type_coerce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">mysql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">type_coerce</span><span class="p">({</span><span class="s2">&quot;some_key&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">}},</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;some_key&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">mysql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">JSON_EXTRACT</span><span class="p">(</span><span class="o">%</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>上面，MySQL 的 <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> SQL 函数被调用，因为我们使用 <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> 指示我们的 Python 字典应被视为 <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>。Python 的 <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> 运算符，在本例中为 <code class="docutils literal notranslate"><span class="pre">['some_key']</span></code>，因此可用并允许呈现 <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> 路径表达式（未显示，但在本例中最终将是 <code class="docutils literal notranslate"><span class="pre">'$.&quot;some_key&quot;'</span></code>）。</p>
</div>
<input class="tab-input" id="tab-set--33-input--2" name="tab-set--33" type="radio"><label class="tab-label" for="tab-set--33-input--2">英文</label><div class="tab-content docutils container">
<p>Sometimes there is the need to have SQLAlchemy know the datatype of an
expression, for all the reasons mentioned above, but to not render the CAST
expression itself on the SQL side, where it may interfere with a SQL operation
that already works without it.  For this fairly common use case there is
another function <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> which is closely related to
<a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.cast" title="sqlalchemy.sql.expression.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a>, in that it sets up a Python expression as having a specific SQL
database type, but does not render the <code class="docutils literal notranslate"><span class="pre">CAST</span></code> keyword or datatype on the
database side.    <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> is particularly important when dealing
with the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a> datatype, which typically has an intricate
relationship with string-oriented datatypes on different platforms and
may not even be an explicit datatype, such as on SQLite and MariaDB.
Below, we use <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> to deliver a Python structure as a JSON
string into one of MySQL’s JSON functions:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">JSON</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy</span><span class="w"> </span><span class="kn">import</span> <span class="n">type_coerce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.dialects</span><span class="w"> </span><span class="kn">import</span> <span class="n">mysql</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">type_coerce</span><span class="p">({</span><span class="s2">&quot;some_key&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;foo&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">}},</span> <span class="n">JSON</span><span class="p">)[</span><span class="s2">&quot;some_key&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dialect</span><span class="o">=</span><span class="n">mysql</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">JSON_EXTRACT</span><span class="p">(</span><span class="o">%</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">%</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">anon_1</span>
</div></pre></div>
</div>
<p>Above, MySQL’s <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> SQL function was invoked
because we used <a class="reference internal" href="../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce" title="sqlalchemy.sql.expression.type_coerce"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_coerce()</span></code></a> to indicate that our Python dictionary
should be treated as <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.JSON" title="sqlalchemy.types.JSON"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSON</span></code></a>.  The Python <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>
operator, <code class="docutils literal notranslate"><span class="pre">['some_key']</span></code> in this case, became available as a result and
allowed a <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> path expression (not shown, however in this
case it would ultimately be <code class="docutils literal notranslate"><span class="pre">'$.&quot;some_key&quot;'</span></code>) to be rendered.</p>
</div>
</div>
</section>
</section>
</section>
<aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>Next Tutorial Section: <a class="reference internal" href="data_update.html"><span class="doc">使用 UPDATE 和 DELETE 语句</span></a></p>
</aside>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="data_update.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">使用 UPDATE 和 DELETE 语句</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="data_insert.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">使用 INSERT 语句</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                <a href="../copyright.html">Copyright</a> &#169; 2007-2025, the SQLAlchemy authors and contributors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on 04/05/2025 04:00:26</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">使用 SELECT 语句</a><ul>
<li><a class="reference internal" href="#select-sql">select() SQL 表达式构造</a></li>
<li><a class="reference internal" href="#columns-from">设置 COLUMNS 和 FROM 子句</a><ul>
<li><a class="reference internal" href="#orm">选择 ORM 实体和列</a></li>
<li><a class="reference internal" href="#sql">从带标签的 SQL 表达式中选择</a></li>
<li><a class="reference internal" href="#tutorial-select-arbitrary-text">使用文本列表达式进行选择</a></li>
</ul>
</li>
<li><a class="reference internal" href="#where">WHERE 子句</a></li>
<li><a class="reference internal" href="#from-join">显式 FROM 子句和 JOIN</a><ul>
<li><a class="reference internal" href="#on">设置 ON 子句</a></li>
<li><a class="reference internal" href="#outer-full">OUTER 和 FULL 连接</a></li>
</ul>
</li>
<li><a class="reference internal" href="#order-bygroup-byhaving">ORDER BY、GROUP BY、HAVING</a><ul>
<li><a class="reference internal" href="#order-by">ORDER BY</a></li>
<li><a class="reference internal" href="#group-by-having">使用 GROUP BY / HAVING 的聚合函数</a></li>
<li><a class="reference internal" href="#tutorial-order-by-label">按标签排序或分组</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-using-aliases">使用别名</a><ul>
<li><a class="reference internal" href="#tutorial-orm-entity-aliases">ORM 实体别名</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cte">子查询和 CTE</a><ul>
<li><a class="reference internal" href="#id5">通用表表达式 (CTE)</a></li>
<li><a class="reference internal" href="#orm-cte">ORM 实体子查询/CTE</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-scalar-subquery">标量和相关子查询</a><ul>
<li><a class="reference internal" href="#lateral">LATERAL 相关</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unionunion-all">UNION、UNION ALL 和其他集合操作</a><ul>
<li><a class="reference internal" href="#tutorial-orm-union">从联合中选择 ORM 实体</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exists">EXISTS 子查询</a></li>
<li><a class="reference internal" href="#tutorial-functions">使用 SQL 函数</a><ul>
<li><a class="reference internal" href="#id9">函数具有返回类型</a></li>
<li><a class="reference internal" href="#id10">内置函数具有预配置的返回类型</a></li>
<li><a class="reference internal" href="#id11">高级 SQL 函数技术</a><ul>
<li><a class="reference internal" href="#tutorial-window-functions">使用窗口函数</a></li>
<li><a class="reference internal" href="#within-groupfilter">特殊修饰符 WITHIN GROUP、FILTER</a></li>
<li><a class="reference internal" href="#tutorial-functions-table-valued">表值函数</a></li>
<li><a class="reference internal" href="#tutorial-functions-column-valued">列值函数 - 表值函数作为标量列</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-casts">数据强制转换和类型强制转换</a><ul>
<li><a class="reference internal" href="#type-coerce-python">type_coerce() - 仅限 Python 的“强制转换”</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=2d0eb83f"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/tabs.js?v=3ee01567"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=2f3e6152"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    </body>
</html>