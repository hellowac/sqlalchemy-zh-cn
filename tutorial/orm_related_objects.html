<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="索引" href="../genindex.html" /><link rel="search" title="搜索" href="../search.html" /><link rel="copyright" title="版权所有" href="../copyright.html" /><link rel="next" title="进一步阅读" href="further_reading.html" /><link rel="prev" title="使用 ORM 进行数据操作" href="orm_data_manipulation.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.08.06 -->
        <title>使用 ORM 相关对象 - SQLAlchemy 2.1 Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css?v=4c969af8" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/changelog.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_paramlinks.css" />
    <link rel="stylesheet" type="text/css" href="../_static/docs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">SQLAlchemy 2.1 Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">SQLAlchemy 2.1 Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="搜索" name="q" aria-label="搜索">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">概述</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">SQLAlchemy 统一教程</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of SQLAlchemy 统一教程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="engine.html">建立连接 - Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="dbapi_transactions.html">使用事务和DBAPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="metadata.html">使用数据库元数据</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="data.html">处理数据</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of 处理数据</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="data_insert.html">使用 INSERT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_select.html">使用 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_update.html">使用 UPDATE 和 DELETE 语句</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="orm_data_manipulation.html">使用 ORM 进行数据操作</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">使用 ORM 相关对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="further_reading.html">进一步阅读</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../orm/index.html">SQLAlchemy ORM</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of SQLAlchemy ORM</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../orm/quickstart.html">ORM 快速入门</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/mapper_config.html">ORM 映射类配置</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of ORM 映射类配置</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapping_styles.html">ORM 映射类概述</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../orm/declarative_mapping.html">使用声明式映射类</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 使用声明式映射类</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_styles.html">声明式映射风格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_tables.html">声明式的表配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_config.html">使用声明式映射器配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="../orm/declarative_mixins.html">使用 Mixins 组合映射层次结构</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../orm/dataclasses.html">与dataclass和attrs的集成</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapped_sql_expr.html">SQL 表达式作为映射属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapped_attributes.html">更改Attribute的行为</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/composites.html">复合列类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/inheritance.html">映射类继承层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/nonstandard_mappings.html">非传统映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/versioning.html">配置版本计数器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/mapping_api.html">类映射 API</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../orm/scalar_mapping.html">映射 SQL 表达式</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 映射 SQL 表达式</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../orm/mapping_columns.html">映射表格列</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/relationships.html">关系配置</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of 关系配置</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/basic_relationships.html">基本关系模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/self_referential.html">邻接表关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/join_conditions.html">配置关系连接方式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/large_collections.html">使用大型集合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/collection_api.html">集合自定义和 API 详细信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/relationship_persistence.html">特殊关系的持久化模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/backref.html">使用旧版“backref”关系参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/relationship_api.html">关系 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/queryguide/index.html">ORM 查询指南</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of ORM 查询指南</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/select.html">为 ORM 映射类编写 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/inheritance.html">为继承映射编写 SELECT 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/dml.html">启用 ORM 的 INSERT、UPDATE 和 DELETE 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/columns.html">列加载选项</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/relationships.html">关系加载技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/api.html">用于查询的 ORM API 功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/queryguide/query.html">旧式查询 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/session.html">使用会话</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 使用会话</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_basics.html">会话基础知识</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_state_management.html">状态管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/cascades.html">级联</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_transaction.html">事务和连接管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/persistence_techniques.html">附加持久性技术</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/contextual.html">上下文/线程本地会话</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_events.html">使用事件跟踪查询、对象和会话更改</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/session_api.html">会话 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/extending.html">事件和内部</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of 事件和内部</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/events.html">ORM 事件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/internals.html">ORM 内部</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/exceptions.html">ORM 异常</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../orm/extensions/index.html">ORM 扩展</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of ORM 扩展</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/asyncio.html">异步 I/O (asyncio)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/associationproxy.html">关联代理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/automap.html">自动映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/baked.html">烘焙查询</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/declarative/index.html">声明式扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/mutable.html">突变追踪</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/orderinglist.html">排序列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/horizontal_shard.html">水平分片</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/hybrid.html">混合属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/indexable.html">Indexable</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orm/extensions/instrumentation.html">替代类检测</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../orm/examples.html">核心和 ORM 示例</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../core/index.html">SQLAlchemy Core</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of SQLAlchemy Core</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/expression_api.html">SQL 语句和表达式 API</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of SQL 语句和表达式 API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/sqlelement.html">列元素和表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/operators.html">操作符参考</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/selectable.html">SELECT 和相关构造</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/dml.html">插入,更新,删除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/functions.html">SQL 和 范型函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/compiler.html">自定义 SQL 构造和编译扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/serializer.html">表达式序列化器扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/foundation.html">SQL 表达式语言基础构造</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/visitors.html">访问者和遍历实用程序</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/schema.html">Schema 定义语言</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of Schema 定义语言</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/metadata.html">使用元数据描述数据库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/reflection.html">反映数据库对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/defaults.html">列 INSERT/UPDATE 默认值</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/constraints.html">定义约束和索引</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/ddl.html">自定义 DDL</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/types.html">SQL 数据类型对象</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of SQL 数据类型对象</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/type_basics.html">类型层次结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/custom_types.html">自定义类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/type_api.html">基本类型 API</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/engines_connections.html">Engine和Connection的使用</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle navigation of Engine和Connection的使用</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/engines.html">Engine 配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/connections.html">使用Engines和Connection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/pooling.html">连接池</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/events.html">核心事件</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../core/api_basics.html">Core API 基础</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle navigation of Core API 基础</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../core/event.html">事件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/inspection.html">运行时审查 API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/exceptions.html">Core 异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core/internals.html">Core 内部</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../dialects/index.html">Dialects</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle navigation of Dialects</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../dialects/postgresql.html">PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/mysql.html">MySQL 和 MariaDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/sqlite.html">SQLite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/oracle.html">Oracle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dialects/mssql.html">Microsoft SQL Server</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../faq/index.html">常见问题</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle navigation of 常见问题</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/installation.html">安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/connections.html">连接 / 引擎</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/metadata_schema.html">元数据 / Schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/sqlexpressions.html">SQL 表达式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/ormconfiguration.html">ORM 配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/performance.html">性能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/sessions.html">会话 / 查询</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/thirdparty.html">第三方包集成问题</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../errors.html">错误消息</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../changelog/index.html">变更和迁移</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle navigation of 变更和迁移</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_21.html">SQLAlchemy 2.1 有什么新功能？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_21.html">2.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_20.html">2.0 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_14.html">1.4 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_13.html">1.3 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_12.html">1.2 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_11.html">1.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_10.html">1.0 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_09.html">0.9 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_08.html">0.8 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_07.html">0.7 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_06.html">0.6 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_05.html">0.5 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_04.html">0.4 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_03.html">0.3 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_02.html">0.2 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/changelog_01.html">0.1 Changelog</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_20.html">SQLAlchemy 2.0 - Major Migration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/whatsnew_20.html">What’s New in SQLAlchemy 2.0?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_14.html">What’s New in SQLAlchemy 1.4?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_13.html">What’s New in SQLAlchemy 1.3?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_12.html">What’s New in SQLAlchemy 1.2?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_11.html">What’s New in SQLAlchemy 1.1?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_10.html">What’s New in SQLAlchemy 1.0?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_09.html">What’s New in SQLAlchemy 0.9?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_08.html">What’s New in SQLAlchemy 0.8?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_07.html">What’s New in SQLAlchemy 0.7?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_06.html">What’s New in SQLAlchemy 0.6?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_05.html">What’s new in SQLAlchemy 0.5?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog/migration_04.html">What’s new in SQLAlchemy 0.4?</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          

<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>This page is part of the <a class="reference internal" href="index.html"><span class="doc">SQLAlchemy 统一教程</span></a>.</p>
<p>Previous: <a class="reference internal" href="orm_data_manipulation.html"><span class="doc">使用 ORM 进行数据操作</span></a>   |   Next: <a class="reference internal" href="further_reading.html"><span class="doc">进一步阅读</span></a></p>
</aside>
<section class="orm-header" id="orm">
<span id="tutorial-orm-related-objects"></span><h1>使用 ORM 相关对象<a class="headerlink" href="#orm" title="Link to this heading">¶</a></h1>
<p>Working with ORM Related Objects</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--0-input--1" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--1">中文</label><div class="tab-content docutils container">
<p>在本节中，我们将介绍另一个基本的 ORM 概念，即 ORM 如何与引用其他对象的映射类进行交互。在 <a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a> 部分中，映射类示例使用了一个称为 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 的构造。此构造定义了两个不同的映射类之间的链接，或者从映射类到自身的链接，后者称为 <strong>self-referential</strong> 关系。</p>
<p>为了描述 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 的基本思想，首先我们将简要回顾映射，省略 <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> 映射和其他指令：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>

<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>上面，<code class="docutils literal notranslate"><span class="pre">User</span></code> 类现在有一个属性 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>， <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类有一个属性 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>。 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造与 <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> 构造相结合以指示类型行为，将用于检查映射到 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象之间的表关系。由于表示 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象具有引用 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>，<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 可以明确确定从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 类到 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类的 <a class="reference internal" href="../glossary.html#term-one-to-many"><span class="xref std std-term">one to many</span></a> 关系，沿着 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 关系； <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表中的一行可能被 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中的多行引用。</p>
<p>所有一对多关系自然地对应于相反方向的 <a class="reference internal" href="../glossary.html#term-many-to-one"><span class="xref std std-term">many to one</span></a> 关系，在本例中是 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 所指出的关系。<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> 参数，如上所述在指向其他名称的两个 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 对象上配置，建立了这两个 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造应被视为互补的；我们将在下一节中看到这如何发挥作用。</p>
</div>
<input class="tab-input" id="tab-set--0-input--2" name="tab-set--0" type="radio"><label class="tab-label" for="tab-set--0-input--2">英文</label><div class="tab-content docutils container">
<p>In this section, we will cover one more essential ORM concept, which is
how the ORM interacts with mapped classes that refer to other objects. In the
section <a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a>, the mapped class examples
made use of a construct called <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>.  This construct
defines a linkage between two different mapped classes, or from a mapped class
to itself, the latter of which is called a <strong>self-referential</strong> relationship.</p>
<p>To describe the basic idea of <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>, first we’ll review
the mapping in short form, omitting the <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> mappings
and other directives:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>

    <span class="c1"># ... mapped_column() mappings</span>

    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">User</span></code> class now has an attribute <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> and the
<code class="docutils literal notranslate"><span class="pre">Address</span></code> class has an attribute <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>.   The
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> construct, in conjunction with the
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> construct to indicate typing behavior, will be used to
inspect the table relationships between the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects that
are mapped to the <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> classes. As the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object representing the <code class="docutils literal notranslate"><span class="pre">address</span></code> table has a
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> which refers to the <code class="docutils literal notranslate"><span class="pre">user_account</span></code>
table, the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> can determine unambiguously that there is
a <a class="reference internal" href="../glossary.html#term-one-to-many"><span class="xref std std-term">one to many</span></a> relationship from the <code class="docutils literal notranslate"><span class="pre">User</span></code> class to the <code class="docutils literal notranslate"><span class="pre">Address</span></code>
class, along the <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> relationship; one particular row in the
<code class="docutils literal notranslate"><span class="pre">user_account</span></code> table may be referenced by many rows in the <code class="docutils literal notranslate"><span class="pre">address</span></code>
table.</p>
<p>All one-to-many relationships naturally correspond to a <a class="reference internal" href="../glossary.html#term-many-to-one"><span class="xref std std-term">many to one</span></a>
relationship in the other direction, in this case the one noted by
<code class="docutils literal notranslate"><span class="pre">Address.user</span></code>. The <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> parameter,
seen above configured on both <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects referring to
the other name, establishes that each of these two <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
constructs should be considered to be complimentary to each other; we will see
how this plays out in the next section.</p>
</div>
</div>
<section id="id1">
<h2>持久化和加载关系<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<p>Persisting and Loading Relationships</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--1-input--1" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--1">中文</label><div class="tab-content docutils container">
<p>我们可以通过实例化对象来说明 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 的作用。如果我们创建一个新的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象，可以注意到当我们访问 <code class="docutils literal notranslate"><span class="pre">.addresses</span></code> 元素时会有一个 Python 列表:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;pkrabs&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Pearl Krabs&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span></pre></div>
</div>
<p>这个对象是一个 SQLAlchemy 特定版本的 Python <code class="docutils literal notranslate"><span class="pre">list</span></code>，具有跟踪和响应对其进行的更改的能力。即使我们从未将其分配给对象，当我们访问属性时，集合也会自动出现。这类似于 <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用 ORM 工作单元模式插入行</span></a> 中的行为，其中观察到没有明确分配值的基于列的属性也会自动显示为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，而不是像 Python 的通常行为那样引发 <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>。</p>
<p>由于 <code class="docutils literal notranslate"><span class="pre">u1</span></code> 对象仍然是 <a class="reference internal" href="../glossary.html#term-transient"><span class="xref std std-term">transient</span></a> 的，并且我们从 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 获得的 <code class="docutils literal notranslate"><span class="pre">list</span></code> 尚未发生变化（即附加或扩展），它实际上还没有与对象关联，但随着我们对其进行更改，它将成为 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象状态的一部分。</p>
<p>该集合特定于 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类，这是唯一可以在其中持久保存的 Python 对象类型。使用 <code class="docutils literal notranslate"><span class="pre">list.append()</span></code> 方法，我们可以添加一个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl.krabs@gmail.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></pre></div>
</div>
<p>此时， <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 集合如预期包含新的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;)]</span></pre></div>
</div>
<p>当我们将 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象与 <code class="docutils literal notranslate"><span class="pre">u1</span></code> 实例的 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 集合相关联时，发生了另一种行为，即 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 关系与 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 关系同步，这样我们不仅可以从 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象导航到 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，还可以从 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象导航回“父” <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span>
<span class="go">User(id=None, name=&#39;pkrabs&#39;, fullname=&#39;Pearl Krabs&#39;)</span></pre></div>
</div>
<p>这种同步是由于我们在两个 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 对象之间使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> 参数而发生的。此参数指定应进行互补属性分配/列表变更的另一个 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>。它在另一个方向上也同样有效，即如果我们创建另一个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象并将其分配给 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性，该 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 将成为该 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象上的 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 集合的一部分:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl@aol.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=None, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>实际上，我们在 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 构造函数中使用了 <code class="docutils literal notranslate"><span class="pre">user</span></code> 参数作为关键字参数，接受它就像在 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类上声明的任何其他映射属性一样。它相当于事实上的 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性的赋值:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go"># 等效于 a2 = Address(user=u1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--1-input--2" name="tab-set--1" type="radio"><label class="tab-label" for="tab-set--1-input--2">英文</label><div class="tab-content docutils container">
<p>We can start by illustrating what <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> does to instances
of objects.   If we make a new <code class="docutils literal notranslate"><span class="pre">User</span></code> object, we can note that there is a
Python list when we access the <code class="docutils literal notranslate"><span class="pre">.addresses</span></code> element:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;pkrabs&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Pearl Krabs&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[]</span></pre></div>
</div>
<p>This object is a SQLAlchemy-specific version of Python <code class="docutils literal notranslate"><span class="pre">list</span></code> which
has the ability to track and respond to changes made to it.  The collection
also appeared automatically when we accessed the attribute, even though we never assigned it to the object.
This is similar to the behavior noted at <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用 ORM 工作单元模式插入行</span></a> where
it was observed that column-based attributes to which we don’t explicitly
assign a value also display as <code class="docutils literal notranslate"><span class="pre">None</span></code> automatically, rather than raising
an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> as would be Python’s usual behavior.</p>
<p>As the <code class="docutils literal notranslate"><span class="pre">u1</span></code> object is still <a class="reference internal" href="../glossary.html#term-transient"><span class="xref std std-term">transient</span></a> and the <code class="docutils literal notranslate"><span class="pre">list</span></code> that we got
from <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> has not been mutated (i.e. appended or extended), it’s
not actually associated with the object yet, but as we make changes to it,
it will become part of the state of the <code class="docutils literal notranslate"><span class="pre">User</span></code> object.</p>
<p>The collection is specific to the <code class="docutils literal notranslate"><span class="pre">Address</span></code> class which is the only type
of Python object that may be persisted within it.  Using the <code class="docutils literal notranslate"><span class="pre">list.append()</span></code>
method we may add an <code class="docutils literal notranslate"><span class="pre">Address</span></code> object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl.krabs@gmail.com&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span></pre></div>
</div>
<p>At this point, the <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> collection as expected contains the
new <code class="docutils literal notranslate"><span class="pre">Address</span></code> object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;)]</span></pre></div>
</div>
<p>As we associated the <code class="docutils literal notranslate"><span class="pre">Address</span></code> object with the <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> collection
of the <code class="docutils literal notranslate"><span class="pre">u1</span></code> instance, another behavior also occurred, which is that the
<code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> relationship synchronized itself with the <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>
relationship, such that we can navigate not only from the <code class="docutils literal notranslate"><span class="pre">User</span></code> object
to the <code class="docutils literal notranslate"><span class="pre">Address</span></code> object, we can also navigate from the <code class="docutils literal notranslate"><span class="pre">Address</span></code> object
back to the “parent” <code class="docutils literal notranslate"><span class="pre">User</span></code> object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">user</span>
<span class="go">User(id=None, name=&#39;pkrabs&#39;, fullname=&#39;Pearl Krabs&#39;)</span></pre></div>
</div>
<p>This synchronization occurred as a result of our use of the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.back_populates</span></code></a> parameter between the two
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects.  This parameter names another
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> for which complementary attribute assignment / list
mutation should occur.   It will work equally well in the other
direction, which is that if we create another <code class="docutils literal notranslate"><span class="pre">Address</span></code> object and assign
to its <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> attribute, that <code class="docutils literal notranslate"><span class="pre">Address</span></code> becomes part of the
<code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> collection on that <code class="docutils literal notranslate"><span class="pre">User</span></code> object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Address</span><span class="p">(</span><span class="n">email_address</span><span class="o">=</span><span class="s2">&quot;pearl@aol.com&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=None, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=None, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>We actually made use of the <code class="docutils literal notranslate"><span class="pre">user</span></code> parameter as a keyword argument in the
<code class="docutils literal notranslate"><span class="pre">Address</span></code> constructor, which is accepted just like any other mapped attribute
that was declared on the <code class="docutils literal notranslate"><span class="pre">Address</span></code> class.  It is equivalent to assignment
of the <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> attribute after the fact:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="go"># equivalent effect as a2 = Address(user=u1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">u1</span></pre></div>
</div>
</div>
</div>
<section id="tutorial-orm-cascades">
<span id="id2"></span><h3>将对象级联到会话中<a class="headerlink" href="#tutorial-orm-cascades" title="Link to this heading">¶</a></h3>
<p>Cascading Objects into the Session</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--2-input--1" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--1">中文</label><div class="tab-content docutils container">
<p>我们现在有一个 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和两个 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，它们在内存中以双向结构关联，但如 <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用 ORM 工作单元模式插入行</span></a> 中所述，这些对象在与 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 对象关联之前，处于 <a class="reference internal" href="../glossary.html#term-transient"><span class="xref std std-term">transient</span></a> 状态。</p>
<p>我们使用仍在进行的 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>，并注意到当我们将 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> 方法应用于主要的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象时，相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象也会添加到同一个 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 中:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span></pre></div>
</div>
<p>上述行为，即 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 接收到一个 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象，并沿着 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> 关系找到相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象，被称为 <strong>自级联更新(save-update cascade)</strong>，在 ORM 参考文档 <a class="reference internal" href="../orm/cascades.html#unitofwork-cascades"><span class="std std-ref">级联</span></a> 中有详细讨论。</p>
<p>这三个对象现在处于 <a class="reference internal" href="../glossary.html#term-pending"><span class="xref std std-term">pending</span></a> 状态；这意味着它们准备好成为 INSERT 操作的主题，但尚未进行；所有三个对象都没有分配主键，此外，<code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 对象有一个称为 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 的属性，该属性引用了具有 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>，该约束引用了 <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> 列；这些也为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，因为这些对象尚未与实际数据库行关联:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">None</span></pre></div>
</div>
<p>在这个阶段，我们可以看到 unit of work 过程提供的巨大实用性；回想在 <a class="reference internal" href="data_insert.html#tutorial-core-insert-values-clause"><span class="std std-ref">INSERT 通常会自动生成“values”子句</span></a> 部分中，使用一些复杂的语法将行插入到 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 和 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中，以便自动将 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列与 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行相关联。此外，有必要首先为 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行发出 INSERT，然后是 <code class="docutils literal notranslate"><span class="pre">address</span></code>，因为 <code class="docutils literal notranslate"><span class="pre">address</span></code> 中的行 <strong>依赖</strong> <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 中的父行来获取其 <code class="docutils literal notranslate"><span class="pre">user_id</span></code> 列中的值。</p>
<p>使用 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 时，所有这些繁琐的工作都为我们处理了，即使是最顽固的 SQL 纯粹主义者也可以从 INSERT、UPDATE 和 DELETE 语句的自动化中受益。当我们 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> 事务时，所有步骤都按正确的顺序调用，此外，新生成的 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 行的主键也适当地应用于 <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> 列：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<div class='show_sql'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">fullname</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Pearl Krabs&#39;</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[...</span><span class="w"> </span><span class="p">(</span><span class="n">insertmanyvalues</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl.krabs@gmail.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[</span><span class="n">insertmanyvalues</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl@aol.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
</div>
<input class="tab-input" id="tab-set--2-input--2" name="tab-set--2" type="radio"><label class="tab-label" for="tab-set--2-input--2">英文</label><div class="tab-content docutils container">
<p>We now have a <code class="docutils literal notranslate"><span class="pre">User</span></code> and two <code class="docutils literal notranslate"><span class="pre">Address</span></code> objects that are associated in a
bidirectional structure
in memory, but as noted previously in <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">使用 ORM 工作单元模式插入行</span></a> ,
these objects are said to be in the <a class="reference internal" href="../glossary.html#term-transient"><span class="xref std std-term">transient</span></a> state until they
are associated with a <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> object.</p>
<p>We make use of the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> that’s still ongoing, and note that
when we apply the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.add" title="sqlalchemy.orm.Session.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.add()</span></code></a> method to the lead <code class="docutils literal notranslate"><span class="pre">User</span></code> object,
the related <code class="docutils literal notranslate"><span class="pre">Address</span></code> object also gets added to that same <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="ow">in</span> <span class="n">session</span>
<span class="go">True</span></pre></div>
</div>
<p>The above behavior, where the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> received a <code class="docutils literal notranslate"><span class="pre">User</span></code> object,
and followed along the <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> relationship to locate a related
<code class="docutils literal notranslate"><span class="pre">Address</span></code> object, is known as the <strong>save-update cascade</strong> and is discussed
in detail in the ORM reference documentation at <a class="reference internal" href="../orm/cascades.html#unitofwork-cascades"><span class="std std-ref">级联</span></a>.</p>
<p>The three objects are now in the <a class="reference internal" href="../glossary.html#term-pending"><span class="xref std std-term">pending</span></a> state; this means they are
ready to be the subject of an INSERT operation but this has not yet proceeded;
all three objects have no primary key assigned yet, and in addition, the <code class="docutils literal notranslate"><span class="pre">a1</span></code>
and <code class="docutils literal notranslate"><span class="pre">a2</span></code> objects have an attribute called <code class="docutils literal notranslate"><span class="pre">user_id</span></code> which refers to the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> that has a <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
referring to the <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> column; these are also <code class="docutils literal notranslate"><span class="pre">None</span></code> as the
objects are not yet associated with a real database row:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">u1</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
<span class="go">None</span></pre></div>
</div>
<p>It’s at this stage that we can see the very great utility that the unit of
work process provides; recall in the section <a class="reference internal" href="data_insert.html#tutorial-core-insert-values-clause"><span class="std std-ref">INSERT 通常会自动生成“values”子句</span></a>,
rows were inserted into the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> and
<code class="docutils literal notranslate"><span class="pre">address</span></code> tables using some elaborate syntaxes in order to automatically
associate the <code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> columns with those of the <code class="docutils literal notranslate"><span class="pre">user_account</span></code>
rows.  Additionally, it was necessary that we emit INSERT for <code class="docutils literal notranslate"><span class="pre">user_account</span></code>
rows first, before those of <code class="docutils literal notranslate"><span class="pre">address</span></code>, since rows in <code class="docutils literal notranslate"><span class="pre">address</span></code> are
<strong>dependent</strong> on their parent row in <code class="docutils literal notranslate"><span class="pre">user_account</span></code> for a value in their
<code class="docutils literal notranslate"><span class="pre">user_id</span></code> column.</p>
<p>When using the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, all this tedium is handled for us and
even the most die-hard SQL purist can benefit from automation of INSERT,
UPDATE and DELETE statements.   When we <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> the
transaction all steps invoke in the correct order, and furthermore the
newly generated primary key of the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> row is applied to the
<code class="docutils literal notranslate"><span class="pre">address.user_id</span></code> column appropriately:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<div class='show_sql'><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">fullname</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Pearl Krabs&#39;</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[...</span><span class="w"> </span><span class="p">(</span><span class="n">insertmanyvalues</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl.krabs@gmail.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span><span class="w"> </span><span class="k">RETURNING</span><span class="w"> </span><span class="n">id</span>
<span class="p">[</span><span class="n">insertmanyvalues</span><span class="w"> </span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">ordered</span><span class="p">;</span><span class="w"> </span><span class="n">batch</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">supported</span><span class="p">)]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pearl@aol.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
<span class="k">COMMIT</span>
</div></pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="tutorial-loading-relationships">
<span id="id3"></span><h2>加载关系<a class="headerlink" href="#tutorial-loading-relationships" title="Link to this heading">¶</a></h2>
<p>Loading Relationships</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--3-input--1" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--1">中文</label><div class="tab-content docutils container">
<p>在最后一步中，我们调用了 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a>，它为事务发出了 COMMIT，然后根据 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.commit.expire_on_commit</span></code></a> 使所有对象过期，以便它们在下一个事务中刷新。</p>
<p>当我们下一次访问这些对象上的属性时，我们将看到为行的主要属性发出的 SELECT，例如当我们查看 <code class="docutils literal notranslate"><span class="pre">u1</span></code> 对象的新生成的主键时：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">id</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_name</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">6</span></pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">u1</span></code> <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象现在有一个持久化集合 <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>，我们也可以访问。由于该集合由 <code class="docutils literal notranslate"><span class="pre">address</span></code> 表中的另一组行组成，当我们访问该集合时，我们再次看到发出的 <a class="reference internal" href="../glossary.html#term-lazy-load"><span class="xref std std-term">lazy load</span></a> 以检索对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>SQLAlchemy ORM 中的集合和相关属性在内存中是持久的；一旦集合或属性填充，SQL 将不再发出，直到该集合或属性 <a class="reference internal" href="../glossary.html#term-expired"><span class="xref std std-term">expired</span></a>。我们可以再次访问 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 并添加或删除项目，这不会产生任何新的 SQL 调用:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>虽然如果我们不采取明确步骤进行优化，lazy loading 发出的加载可能会迅速变得昂贵，但 lazy loading 网络至少经过了相当好的优化，不会执行重复工作；由于 <code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> 集合已刷新，根据 <a class="reference internal" href="../glossary.html#term-identity-map"><span class="xref std std-term">identity map</span></a>，这些实际上是我们已经处理的 <code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 对象的相同 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 实例，因此我们完成了此特定对象图中所有属性的加载:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span>
<span class="go">Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span>
<span class="go">Address(id=5, email_address=&#39;pearl@aol.com&#39;)</span></pre></div>
</div>
<p>关系如何加载或不加载的问题本身就是一个完整的主题。对此概念的一些额外介绍将在本节稍后的 <a class="reference internal" href="#tutorial-orm-loader-strategies"><span class="std std-ref">加载器策略</span></a> 中进行。</p>
</div>
<input class="tab-input" id="tab-set--3-input--2" name="tab-set--3" type="radio"><label class="tab-label" for="tab-set--3-input--2">英文</label><div class="tab-content docutils container">
<p>In the last step, we called <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.commit()</span></code></a> which emitted a COMMIT
for the transaction, and then per
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit" title="sqlalchemy.orm.Session.commit"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Session.commit.expire_on_commit</span></code></a> expired all objects so that
they refresh for the next transaction.</p>
<p>When we next access an attribute on these objects, we’ll see the SELECT
emitted for the primary attributes of the row, such as when we view the
newly generated primary key for the <code class="docutils literal notranslate"><span class="pre">u1</span></code> object:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">id</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_name</span><span class="p">,</span>
<span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">6</span></pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">u1</span></code> <code class="docutils literal notranslate"><span class="pre">User</span></code> object now has a persistent collection <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code>
that we may also access.   As this collection consists of an additional set
of rows from the <code class="docutils literal notranslate"><span class="pre">address</span></code> table, when we access this collection as well
we again see a <a class="reference internal" href="../glossary.html#term-lazy-load"><span class="xref std std-term">lazy load</span></a> emitted in order to retrieve the objects:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">,)</span>
</div><span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>Collections and related attributes in the SQLAlchemy ORM are persistent in
memory; once the collection or attribute is populated, SQL is no longer emitted
until that collection or attribute is <a class="reference internal" href="../glossary.html#term-expired"><span class="xref std std-term">expired</span></a>.    We may access
<code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> again as well as add or remove items and this will not
incur any new SQL calls:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="go">[Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;), Address(id=5, email_address=&#39;pearl@aol.com&#39;)]</span></pre></div>
</div>
<p>While the loading emitted by lazy loading can quickly become expensive if
we don’t take explicit steps to optimize it, the network of lazy loading
at least is fairly well optimized to not perform redundant work; as the
<code class="docutils literal notranslate"><span class="pre">u1.addresses</span></code> collection was refreshed, per the <a class="reference internal" href="../glossary.html#term-identity-map"><span class="xref std std-term">identity map</span></a>
these are in fact the same
<code class="docutils literal notranslate"><span class="pre">Address</span></code> instances as the <code class="docutils literal notranslate"><span class="pre">a1</span></code> and <code class="docutils literal notranslate"><span class="pre">a2</span></code> objects we’ve been dealing with
already, so we’re done loading all attributes in this particular object
graph:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span>
<span class="go">Address(id=4, email_address=&#39;pearl.krabs@gmail.com&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span>
<span class="go">Address(id=5, email_address=&#39;pearl@aol.com&#39;)</span></pre></div>
</div>
<p>The issue of how relationships load, or not, is an entire subject onto
itself.  Some additional introduction to these concepts is later in this
section at <a class="reference internal" href="#tutorial-orm-loader-strategies"><span class="std std-ref">加载器策略</span></a>.</p>
</div>
</div>
</section>
<section id="tutorial-select-relationships">
<span id="id4"></span><h2>在查询中使用关系<a class="headerlink" href="#tutorial-select-relationships" title="Link to this heading">¶</a></h2>
<p>Using Relationships in Queries</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--4-input--1" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--1">中文</label><div class="tab-content docutils container">
<p>前一节介绍了 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造在处理 <strong>映射类实例(instances of a mapped class)</strong> 时的行为，如上所示，即 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类的 <code class="docutils literal notranslate"><span class="pre">u1</span></code>、 <code class="docutils literal notranslate"><span class="pre">a1</span></code> 和 <code class="docutils literal notranslate"><span class="pre">a2</span></code> 实例。在本节中，我们介绍 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 在 <strong>映射类的类级行为(class level behavior of a mapped class)</strong> 中的应用，它在多种方式上有助于自动构建 SQL 查询。</p>
</div>
<input class="tab-input" id="tab-set--4-input--2" name="tab-set--4" type="radio"><label class="tab-label" for="tab-set--4-input--2">英文</label><div class="tab-content docutils container">
<p>The previous section introduced the behavior of the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
construct when working with <strong>instances of a mapped class</strong>, above, the
<code class="docutils literal notranslate"><span class="pre">u1</span></code>, <code class="docutils literal notranslate"><span class="pre">a1</span></code> and <code class="docutils literal notranslate"><span class="pre">a2</span></code> instances of the <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> classes.
In this section, we introduce the behavior of <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> as it
applies to <strong>class level behavior of a mapped class</strong>, where it serves in
several ways to help automate the construction of SQL queries.</p>
</div>
</div>
<section id="tutorial-joining-relationships">
<span id="id5"></span><h3>使用关系进行连接<a class="headerlink" href="#tutorial-joining-relationships" title="Link to this heading">¶</a></h3>
<p>Using Relationships to Join</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--5-input--1" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--1">中文</label><div class="tab-content docutils container">
<p>部分 <a class="reference internal" href="data_select.html#tutorial-select-join"><span class="std std-ref">显式 FROM 子句和 JOIN</span></a> 和 <a class="reference internal" href="data_select.html#tutorial-select-join-onclause"><span class="std std-ref">设置 ON 子句</span></a> 介绍了使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 方法来组成 SQL JOIN 子句。为了描述表之间的连接方式，这些方法要么基于表元数据结构中链接两个表的单个明确的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> 对象来推断 ON 子句，要么我们可以提供一个显式的 SQL 表达式构造来指示特定的 ON 子句。</p>
<p>在使用 ORM 实体时，还有一种额外的机制可以帮助我们设置连接的 ON 子句，即使用在我们的用户映射中设置的 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 对象，如 <a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a> 中所示。类绑定的对应于 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 的属性可以作为 <strong>单个参数</strong> 传递给 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>，它用来同时表示连接的右侧和 ON 子句:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>如果我们不指定 ON 子句，映射上的 ORM <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 不会被 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 或 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 用来推断 ON 子句。这意味着，如果我们在 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 之间没有 ON 子句的情况下连接，它之所以有效，是因为两个映射的 <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> 对象之间的 <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>，而不是因为 <code class="docutils literal notranslate"><span class="pre">User</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 类上的 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 对象:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>有关如何使用带有 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 构造的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 和 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> 的更多示例，请参见 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中的部分 <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-joins"><span class="std std-ref">连接</span></a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-joins"><span class="std std-ref">连接</span></a> in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--5-input--2" name="tab-set--5" type="radio"><label class="tab-label" for="tab-set--5-input--2">英文</label><div class="tab-content docutils container">
<p>The sections <a class="reference internal" href="data_select.html#tutorial-select-join"><span class="std std-ref">显式 FROM 子句和 JOIN</span></a> and
<a class="reference internal" href="data_select.html#tutorial-select-join-onclause"><span class="std std-ref">设置 ON 子句</span></a> introduced the usage of the
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a> methods to compose
SQL JOIN clauses.   In order to describe how to join between tables, these
methods either <strong>infer</strong> the ON clause based on the presence of a single
unambiguous <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> object within the table
metadata structure that links the two tables, or otherwise we may provide an
explicit SQL Expression construct that indicates a specific ON clause.</p>
<p>When using ORM entities, an additional mechanism is available to help us set up
the ON clause of a join, which is to make use of the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>
objects that we set up in our user mapping, as was demonstrated at
<a class="reference internal" href="metadata.html#tutorial-declaring-mapped-classes"><span class="std std-ref">声明映射类</span></a>. The class-bound attribute
corresponding to the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> may be passed as the <strong>single
argument</strong> to <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a>, where it serves to indicate both the
right side of the join as well as the ON clause at once:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>The presence of an ORM <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> on a mapping is not used
by <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> or <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>
to infer the ON clause if we don’t
specify it.  This means, if we join from <code class="docutils literal notranslate"><span class="pre">User</span></code> to <code class="docutils literal notranslate"><span class="pre">Address</span></code> without an
ON clause, it works because of the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a>
between the two mapped <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects, not because of the
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> objects on the <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code> classes:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">email_address</span><span class="p">)</span><span class="o">.</span><span class="n">join_from</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">Address</span><span class="p">))</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
</div></pre></div>
</div>
<p>See the section <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-joins"><span class="std std-ref">连接</span></a> in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a>
for many more examples of how to use <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> and <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join_from" title="sqlalchemy.sql.expression.Select.join_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join_from()</span></code></a>
with <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> constructs.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-joins"><span class="std std-ref">连接</span></a> in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
</div>
</section>
<section id="where">
<span id="tutorial-relationship-operators"></span><h3>关系 WHERE 运算符<a class="headerlink" href="#where" title="Link to this heading">¶</a></h3>
<p>Relationship WHERE Operators</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--6-input--1" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--1">中文</label><div class="tab-content docutils container">
<p>还有一些与 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 一起提供的其他 SQL 生成助手种类，通常在构建语句的 WHERE 子句时很有用。请参阅 <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中的部分 <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-relationship-operators"><span class="std std-ref">关系 WHERE 运算符</span></a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a> 中的 <a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-relationship-operators"><span class="std std-ref">关系 WHERE 运算符</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--6-input--2" name="tab-set--6" type="radio"><label class="tab-label" for="tab-set--6-input--2">英文</label><div class="tab-content docutils container">
<p>There are some additional varieties of SQL generation helpers that come with
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> which are typically useful when building up the
WHERE clause of a statement.  See the section
<a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-relationship-operators"><span class="std std-ref">关系 WHERE 运算符</span></a> in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/select.html#orm-queryguide-relationship-operators"><span class="std std-ref">关系 WHERE 运算符</span></a> in the <a class="reference internal" href="../orm/queryguide/index.html#queryguide-toplevel"><span class="std std-ref">ORM 查询指南</span></a></p>
</div>
</div>
</div>
</section>
</section>
<section id="tutorial-orm-loader-strategies">
<span id="id6"></span><h2>加载器策略<a class="headerlink" href="#tutorial-orm-loader-strategies" title="Link to this heading">¶</a></h2>
<p>Loader Strategies</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--7-input--1" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--1">中文</label><div class="tab-content docutils container">
<p>在部分 <a class="reference internal" href="#tutorial-loading-relationships"><span class="std std-ref">加载关系</span></a> 中，我们介绍了一个概念，即当我们处理映射对象的实例时，访问默认情况下使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 映射的属性会在集合未填充时发出一个 <a class="reference internal" href="../glossary.html#term-lazy-load"><span class="xref std std-term">lazy load</span></a> 以加载应存在于该集合中的对象。</p>
<p>Lazy loading 是最著名的 ORM 模式之一，也是最具争议的。当内存中的几十个 ORM 对象每个都引用少量未加载的属性时，这些对象的常规操作可能会触发许多额外的查询，最终累积起来（也称为 <a class="reference internal" href="../glossary.html#term-N-plus-one-problem"><span class="xref std std-term">N plus one problem</span></a>），更糟糕的是，它们是隐式发出的。这些隐式查询可能不会被注意到，可能在尝试后由于不再有可用的数据库事务而导致错误，或者在使用替代并发模式（如 <a class="reference internal" href="../orm/extensions/asyncio.html#asyncio-toplevel"><span class="std std-ref">asyncio</span></a>）时，它们实际上根本不起作用。</p>
<p>与此同时，当它与使用中的并发方法兼容且没有引起其他问题时，lazy loading 是一种非常流行且有用的模式。出于这些原因，SQLAlchemy 的 ORM 非常重视能够控制和优化这种加载行为。</p>
<p>最重要的是，有效使用 ORM lazy loading 的第一步是 <strong>测试应用程序，打开 SQL 回显，并观察发出的 SQL</strong>。如果似乎有许多看起来可以更高效地合并为一个的冗余 SELECT 语句，如果在从其 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 中 <a class="reference internal" href="../glossary.html#term-detached"><span class="xref std std-term">detached</span></a> 的对象不适当地发生加载，这时就需要考虑使用 <strong>加载器策略(loader strategies)</strong>。</p>
<p>加载器策略(loader strategies) 表示为对象，可以使用 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.options" title="sqlalchemy.sql.expression.Select.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.options()</span></code></a> 方法与 SELECT 语句关联，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">user_obj</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<span class="p">)</span><span class="o">.</span><span class="n">scalars</span><span class="p">():</span>
    <span class="n">user_obj</span><span class="o">.</span><span class="n">addresses</span>  <span class="c1"># 访问已经加载的 addresses 集合</span></pre></div>
</div>
<p>它们还可以使用 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code></a> 选项作为 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 的默认配置，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>

<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;selectin&quot;</span>
    <span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>每个 loader strategy 对象都会向声明中添加一些信息，这些信息将在 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 决定如何加载和/或访问各种属性时使用。</p>
<p>下面的部分将介绍一些最常用的 loader strategies。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a> 中的两个部分：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-lazy-option"><span class="std std-ref">在映射时配置加载器策略</span></a> - 配置 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 策略的详细信息</p></li>
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-loader-options"><span class="std std-ref">使用加载器选项进行关系加载</span></a> - 使用查询时 <strong>加载器策略(loader strategies)</strong> 的详细信息</p></li>
</ul>
</div>
</div>
<input class="tab-input" id="tab-set--7-input--2" name="tab-set--7" type="radio"><label class="tab-label" for="tab-set--7-input--2">英文</label><div class="tab-content docutils container">
<p>In the section <a class="reference internal" href="#tutorial-loading-relationships"><span class="std std-ref">加载关系</span></a> we introduced the concept
that when we work with instances of mapped objects, accessing the attributes
that are mapped using <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> in the default case will emit
a <a class="reference internal" href="../glossary.html#term-lazy-load"><span class="xref std std-term">lazy load</span></a> when the collection is not populated in order to load
the objects that should be present in this collection.</p>
<p>Lazy loading is one of the most famous ORM patterns, and is also the one that
is most controversial.   When several dozen ORM objects in memory each refer to
a handful of unloaded attributes, routine manipulation of these objects can
spin off many additional queries that can add up (otherwise known as the
<a class="reference internal" href="../glossary.html#term-N-plus-one-problem"><span class="xref std std-term">N plus one problem</span></a>), and to make matters worse they are emitted
implicitly.    These implicit queries may not be noticed, may cause errors
when they are attempted after there’s no longer a database transaction
available, or when using alternative concurrency patterns such as <a class="reference internal" href="../orm/extensions/asyncio.html#asyncio-toplevel"><span class="std std-ref">asyncio</span></a>, they actually won’t work at all.</p>
<p>At the same time, lazy loading is a vastly popular and useful pattern when it
is compatible with the concurrency approach in use and isn’t otherwise causing
problems.   For these reasons, SQLAlchemy’s ORM places a lot of emphasis on
being able to control and optimize this loading behavior.</p>
<p>Above all, the first step in using ORM lazy loading effectively is to <strong>test
the application, turn on SQL echoing, and watch the SQL that is emitted</strong>. If
there seem to be lots of redundant SELECT statements that look very much like
they could be rolled into one much more efficiently, if there are loads
occurring inappropriately for objects that have been <a class="reference internal" href="../glossary.html#term-detached"><span class="xref std std-term">detached</span></a> from
their <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, that’s when to look into using <strong>loader
strategies</strong>.</p>
<p>Loader strategies are represented as objects that may be associated with a
SELECT statement using the <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.options" title="sqlalchemy.sql.expression.Select.options"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.options()</span></code></a> method, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">user_obj</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span>
<span class="p">)</span><span class="o">.</span><span class="n">scalars</span><span class="p">():</span>
    <span class="n">user_obj</span><span class="o">.</span><span class="n">addresses</span>  <span class="c1"># access addresses collection already loaded</span></pre></div>
</div>
<p>They may be also configured as defaults for a <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> using
the <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code></a> option, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>


<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span>
        <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="s2">&quot;selectin&quot;</span>
    <span class="p">)</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>Each loader strategy object adds some kind of information to the statement that
will be used later by the <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> when it is deciding how various
attributes should be loaded and/or behave when they are accessed.</p>
<p>The sections below will introduce a few of the most prominently used
loader strategies.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>Two sections in <a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-lazy-option"><span class="std std-ref">在映射时配置加载器策略</span></a> - details on configuring the strategy on <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a></p></li>
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#relationship-loader-options"><span class="std std-ref">使用加载器选项进行关系加载</span></a> - details on using query-time loader strategies</p></li>
</ul>
</div>
</div>
</div>
<section id="id7">
<h3>选择加载<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h3>
<p>Selectin Load</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--8-input--1" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--1">中文</label><div class="tab-content docutils container">
<p>现代 SQLAlchemy 中最有用的加载器是 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> 加载器选项。此选项解决了最常见形式的“N 加 1”问题，即一组对象引用相关集合。<a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> 将确保特定集合针对整个对象系列在前端使用单个查询加载。它通过一种 SELECT 形式来实现这一点，在大多数情况下可以针对相关表单独发出，而无需引入 JOIN 或子查询，并且只查询那些集合尚未加载的父对象。下面我们通过加载所有 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象及其相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象来说明 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a>；虽然我们只调用一次 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a>，给定一个 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> 构造，但访问数据库时，实际上会发出两个 SELECT 语句，第二个用于获取相关的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">selectinload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(</span>
<span class="go">...         f&quot;{row.User.name}  ({&#39;, &#39;.join(a.email_address for a in row.User.addresses)})&quot;</span>
<span class="go">...     )</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</div><span class="go">spongebob  (spongebob@sqlalchemy.org)</span>
<span class="go">sandy  (sandy@sqlalchemy.org, sandy@squirrelpower.org)</span>
<span class="go">patrick  ()</span>
<span class="go">squidward  ()</span>
<span class="go">ehkrabs  ()</span>
<span class="go">pkrabs  (pearl.krabs@gmail.com, pearl@aol.com)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a> 中的 <a class="reference internal" href="../orm/queryguide/relationships.html#selectin-eager-loading"><span class="std std-ref">选择 IN 加载</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--8-input--2" name="tab-set--8" type="radio"><label class="tab-label" for="tab-set--8-input--2">英文</label><div class="tab-content docutils container">
<p>The most useful loader in modern SQLAlchemy is the
<a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> loader option.  This option solves the most common
form of the “N plus one” problem which is that of a set of objects that refer
to related collections.   <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> will ensure that a particular
collection for a full series of objects are loaded up front using a single
query.   It does this using a SELECT form that in most cases can be emitted
against the related table alone, without the introduction of JOINs or
subqueries, and only queries for those parent objects for which the
collection isn’t already loaded.   Below we illustrate <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a>
by loading all of the <code class="docutils literal notranslate"><span class="pre">User</span></code> objects and all of their related <code class="docutils literal notranslate"><span class="pre">Address</span></code>
objects; while we invoke <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session.execute" title="sqlalchemy.orm.Session.execute"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Session.execute()</span></code></a> only once, given a
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.select" title="sqlalchemy.sql.expression.select"><code class="xref py py-func docutils literal notranslate"><span class="pre">select()</span></code></a> construct, when the database is accessed, there are
in fact two SELECT statements emitted, the second one being to fetch the
related <code class="docutils literal notranslate"><span class="pre">Address</span></code> objects:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">selectinload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">))</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(</span>
<span class="go">...         f&quot;{row.User.name}  ({&#39;, &#39;.join(a.email_address for a in row.User.addresses)})&quot;</span>
<span class="go">...     )</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_email_address</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</div><span class="go">spongebob  (spongebob@sqlalchemy.org)</span>
<span class="go">sandy  (sandy@sqlalchemy.org, sandy@squirrelpower.org)</span>
<span class="go">patrick  ()</span>
<span class="go">squidward  ()</span>
<span class="go">ehkrabs  ()</span>
<span class="go">pkrabs  (pearl.krabs@gmail.com, pearl@aol.com)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#selectin-eager-loading"><span class="std std-ref">选择 IN 加载</span></a> - in <a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a></p>
</div>
</div>
</div>
</section>
<section id="id8">
<h3>连接加载<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h3>
<p>Joined Load</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--9-input--1" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--1">中文</label><div class="tab-content docutils container">
<p><a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> 预加载策略是 SQLAlchemy 中最早的预加载器，它通过向数据库传递的 SELECT 语句添加 JOIN（根据选项可以是外连接或内连接）来加载相关对象。</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> 策略最适合加载相关的多对一对象，因为这只需要将额外的列添加到任何情况下都会获取的主实体行中。为了提高效率，它还接受一个选项 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin" title="sqlalchemy.orm.joinedload"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">joinedload.innerjoin</span></code></a>，以便在我们知道所有 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象都有一个关联的 <code class="docutils literal notranslate"><span class="pre">User</span></code> 的情况下，使用内连接而不是外连接：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">joinedload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .options(joinedload(Address.user, innerjoin=True))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span>
<span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">spongebob@sqlalchemy.org spongebob</span>
<span class="go">sandy@sqlalchemy.org sandy</span>
<span class="go">sandy@squirrelpower.org sandy</span>
<span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> 也适用于集合，即一对多关系，但它具有按递归方式按相关项目成倍增加主行的效果，这使得对于嵌套集合和/或较大集合，结果集的数据量呈数量级增长，因此应根据具体情况评估其使用与 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> 等其他选项的优劣。</p>
<p>重要的是要注意，包含的 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> 语句的 WHERE 和 ORDER BY 条件 <strong>不会针对 joinedload() 渲染的表</strong>。在上面，可以在 SQL 中看到一个 <strong>匿名别名(anonymous alias)</strong> 应用于 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表，因此在查询中无法直接寻址。这个概念在部分 <a class="reference internal" href="../orm/queryguide/relationships.html#zen-of-eager-loading"><span class="std std-ref">连接预加载的禅宗</span></a> 中有更详细的讨论。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>重要的是要注意，多对一预加载通常不是必需的，因为在常见情况下，“N 加 1”问题不太普遍。当许多对象都引用同一个相关对象时，例如许多 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象每个都引用同一个 <code class="docutils literal notranslate"><span class="pre">User</span></code>，SQL 只会为该 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象发出一次使用正常的 lazy loading。当可能时，lazy load 例程将在当前 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 中按主键查找相关对象，而不会发出任何 SQL。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a> 中的 <a class="reference internal" href="../orm/queryguide/relationships.html#joined-eager-loading"><span class="std std-ref">连接预/急加载</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--9-input--2" name="tab-set--9" type="radio"><label class="tab-label" for="tab-set--9-input--2">英文</label><div class="tab-content docutils container">
<p>The <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> eager load strategy is the oldest eager loader in
SQLAlchemy, which augments the SELECT statement that’s being passed to the
database with a JOIN (which may be an outer or an inner join depending on options),
which can then load in related objects.</p>
<p>The <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> strategy is best suited towards loading
related many-to-one objects, as this only requires that additional columns
are added to a primary entity row that would be fetched in any case.
For greater efficiency, it also accepts an option <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin" title="sqlalchemy.orm.joinedload"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">joinedload.innerjoin</span></code></a>
so that an inner join instead of an outer join may be used for a case such
as below where we know that all <code class="docutils literal notranslate"><span class="pre">Address</span></code> objects have an associated
<code class="docutils literal notranslate"><span class="pre">User</span></code>:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">joinedload</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .options(joinedload(Address.user, innerjoin=True))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span>
<span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="go">spongebob@sqlalchemy.org spongebob</span>
<span class="go">sandy@sqlalchemy.org sandy</span>
<span class="go">sandy@squirrelpower.org sandy</span>
<span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> also works for collections, meaning one-to-many relationships,
however it has the effect
of multiplying out primary rows per related item in a recursive way
that grows the amount of data sent for a result set by orders of magnitude for
nested collections and/or larger collections, so its use vs. another option
such as <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload" title="sqlalchemy.orm.selectinload"><code class="xref py py-func docutils literal notranslate"><span class="pre">selectinload()</span></code></a> should be evaluated on a per-case basis.</p>
<p>It’s important to note that the WHERE and ORDER BY criteria of the enclosing
<a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select" title="sqlalchemy.sql.expression.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">Select</span></code></a> statement <strong>do not target the table rendered by
joinedload()</strong>.   Above, it can be seen in the SQL that an <strong>anonymous alias</strong>
is applied to the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> table such that is not directly addressable
in the query.   This concept is discussed in more detail in the section
<a class="reference internal" href="../orm/queryguide/relationships.html#zen-of-eager-loading"><span class="std std-ref">连接预加载的禅宗</span></a>.</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>It’s important to note that many-to-one eager loads are often not necessary,
as the “N plus one” problem is much less prevalent in the common case. When
many objects all refer to the same related object, such as many <code class="docutils literal notranslate"><span class="pre">Address</span></code>
objects that each refer to the same <code class="docutils literal notranslate"><span class="pre">User</span></code>, SQL will be emitted only once
for that <code class="docutils literal notranslate"><span class="pre">User</span></code> object using normal lazy loading.  The lazy load routine
will look up the related object by primary key in the current
<a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> without emitting any SQL when possible.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#joined-eager-loading"><span class="std std-ref">连接预/急加载</span></a> - in <a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a></p>
</div>
</div>
</div>
</section>
<section id="tutorial-orm-loader-strategies-contains-eager">
<span id="id9"></span><h3>显式连接 + 预加载<a class="headerlink" href="#tutorial-orm-loader-strategies-contains-eager" title="Link to this heading">¶</a></h3>
<p>Explicit Join + Eager load</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--10-input--1" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--1">中文</label><div class="tab-content docutils container">
<p>如果我们在连接到 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 表时使用诸如 <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> 之类的方法来呈现 JOIN，我们还可以利用该 JOIN 来急切加载每个返回的 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象上的 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性的内容。这本质上是我们使用“连接预加载”但自己呈现 JOIN。通过使用 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></a> 选项可以实现这种常见的用例。此选项与 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> 非常相似，只是它假设我们已经设置好了 JOIN，并且它只指示应将 COLUMNS 子句中的其他列加载到每个返回对象的相关属性中，例如：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">contains_eager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .join(Address.user)</span>
<span class="go">...     .where(User.name == &quot;pkrabs&quot;)</span>
<span class="go">...     .options(contains_eager(Address.user))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,)</span>
</div><span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p>上面，我们既过滤了 <code class="docutils literal notranslate"><span class="pre">user_account.name</span></code> 上的行，还将 <code class="docutils literal notranslate"><span class="pre">user_account</span></code> 中的行加载到返回行的 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性中。如果我们分别应用 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>，我们会得到一个不必要地连接两次的 SQL 查询：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="p">(</span><span class="n">Address</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;pkrabs&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">joinedload</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">user</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Address</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>  <span class="c1"># SELECT 不必要地有一个 JOIN 和 LEFT OUTER JOIN</span>
<span class="go">{printsql}SELECT address.id, address.email_address, address.user_id,</span>
<span class="go">user_account_1.id AS id_1, user_account_1.name, user_account_1.fullname</span>
<span class="go">FROM address JOIN user_account ON user_account.id = address.user_id</span>
<span class="go">LEFT OUTER JOIN user_account AS user_account_1 ON user_account_1.id = address.user_id</span>
<span class="go">WHERE user_account.name = :name_1 ORDER BY address.id</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a> 中的两个部分：</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#zen-of-eager-loading"><span class="std std-ref">连接预加载的禅宗</span></a> - 详细描述了上述问题</p></li>
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#contains-eager"><span class="std std-ref">将显式连接/语句路由到预加载的集合</span></a> - 使用 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></a></p></li>
</ul>
</div>
</div>
<input class="tab-input" id="tab-set--10-input--2" name="tab-set--10" type="radio"><label class="tab-label" for="tab-set--10-input--2">英文</label><div class="tab-content docutils container">
<p>If we were to load <code class="docutils literal notranslate"><span class="pre">Address</span></code> rows while joining to the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> table
using a method such as <a class="reference internal" href="../core/selectable.html#sqlalchemy.sql.expression.Select.join" title="sqlalchemy.sql.expression.Select.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Select.join()</span></code></a> to render the JOIN, we could
also leverage that JOIN in order to eagerly load the contents of the
<code class="docutils literal notranslate"><span class="pre">Address.user</span></code> attribute on each <code class="docutils literal notranslate"><span class="pre">Address</span></code> object returned.  This is
essentially that we are using “joined eager loading” but rendering the JOIN
ourselves.   This common use case is achieved by using the
<a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></a> option. This option is very similar to
<a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a>, except that it assumes we have set up the JOIN
ourselves, and it instead only indicates that additional columns in the COLUMNS
clause should be loaded into related attributes on each returned object, for
example:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">contains_eager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .join(Address.user)</span>
<span class="go">...     .where(User.name == &quot;pkrabs&quot;)</span>
<span class="go">...     .options(contains_eager(Address.user))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
<span class="go">...     print(f&quot;{row.Address.email_address} {row.Address.user.name}&quot;)</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">fullname</span><span class="p">,</span>
<span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;pkrabs&#39;</span><span class="p">,)</span>
</div><span class="go">pearl.krabs@gmail.com pkrabs</span>
<span class="go">pearl@aol.com pkrabs</span></pre></div>
</div>
<p>Above, we both filtered the rows on <code class="docutils literal notranslate"><span class="pre">user_account.name</span></code> and also loaded
rows from <code class="docutils literal notranslate"><span class="pre">user_account</span></code> into the <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> attribute of the returned
rows.   If we had applied <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload" title="sqlalchemy.orm.joinedload"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinedload()</span></code></a> separately, we would get a
SQL query that unnecessarily joins twice:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stmt</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     select(Address)</span>
<span class="go">...     .join(Address.user)</span>
<span class="go">...     .where(User.name == &quot;pkrabs&quot;)</span>
<span class="go">...     .options(joinedload(Address.user))</span>
<span class="go">...     .order_by(Address.id)</span>
<span class="go">... )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>  <span class="c1"># SELECT has a JOIN and LEFT OUTER JOIN unnecessarily</span>
<div class='show_sql_print'><span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">email_address</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
<span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">id_1</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">fullname</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">LEFT</span><span class="w"> </span><span class="k">OUTER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">user_account_1</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">user_account_1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">:</span><span class="n">name_1</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span>
</div></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p>Two sections in <a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a>:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#zen-of-eager-loading"><span class="std std-ref">连接预加载的禅宗</span></a> - describes the above problem in detail</p></li>
<li><p><a class="reference internal" href="../orm/queryguide/relationships.html#contains-eager"><span class="std std-ref">将显式连接/语句路由到预加载的集合</span></a> - using <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager" title="sqlalchemy.orm.contains_eager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contains_eager()</span></code></a></p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="id10">
<h3>提升加载<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>Raiseload</p>
<div class="tab-set docutils container">
<input checked="True" class="tab-input" id="tab-set--11-input--1" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--1">中文</label><div class="tab-content docutils container">
<p>另一个值得一提的加载策略是 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a>。此选项用于完全阻止应用程序遇到 <a class="reference internal" href="../glossary.html#term-N-plus-one"><span class="xref std std-term">N plus one</span></a> 问题，通过导致通常会进行的懒加载(lazy load)改为引发错误来实现。它有两个变体，通过 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only" title="sqlalchemy.orm.raiseload"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">raiseload.sql_only</span></code></a> 选项控制，分别阻止需要 SQL 的 懒加载(lazy loads) 和所有“加载”操作，包括仅需查询当前 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 的操作。</p>
<p>使用 <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> 的一种方法是将其配置在 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> 本身上，通过将 <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">&quot;raise_on_sql&quot;</span></code>，使得对于特定映射，某个关系永远不会尝试发出 SQL：</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;user_account&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     addresses: Mapped[List[&quot;Address&quot;]] = relationship(</span>
<span class="go">...         back_populates=&quot;user&quot;, lazy=&quot;raise_on_sql&quot;</span>
<span class="go">...     )</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;address&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     user_id: Mapped[int] = mapped_column(ForeignKey(&quot;user_account.id&quot;))</span>
<span class="go">...     user: Mapped[&quot;User&quot;] = relationship(back_populates=&quot;addresses&quot;, lazy=&quot;raise_on_sql&quot;)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>使用这种映射，应用程序被阻止 lazy loading，表明特定查询需要指定加载策略：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">scalars</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">{execsql}SELECT user_account.id FROM user_account</span>
<span class="go">[...] ()</span>
<span class="go">{stop}&gt;&gt;&gt; u1.addresses</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">sqlalchemy.exc.InvalidRequestError</span>: <span class="n">&#39;User.addresses&#39; is not available due to lazy=&#39;raise_on_sql&#39;</span></pre></div>
</div>
<p>该异常表明应提前加载该集合：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">)</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">selectinload</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">addresses</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">scalars</span><span class="p">()</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{execsql}SELECT user_account.id</span>
<span class="go">FROM user_account</span>
<span class="go">[...] ()</span>
<span class="go">SELECT address.user_id AS address_user_id, address.id AS address_id</span>
<span class="go">FROM address</span>
<span class="go">WHERE address.user_id IN (?, ?, ?, ?, ?, ?)</span>
<span class="go">[...] (1, 2, 3, 4, 5, 6)</span></pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lazy=&quot;raise_on_sql&quot;</span></code> 选项对于多对一关系也尽量智能化；如上所述，如果 <code class="docutils literal notranslate"><span class="pre">Address</span></code> 对象的 <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> 属性未加载，但该 <code class="docutils literal notranslate"><span class="pre">User</span></code> 对象在同一 <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a> 中本地存在，“raiseload” 策略不会引发错误。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a> 中的 <a class="reference internal" href="../orm/queryguide/relationships.html#prevent-lazy-with-raiseload"><span class="std std-ref">使用 raiseload 防止不必要的延迟加载</span></a></p>
</div>
</div>
<input class="tab-input" id="tab-set--11-input--2" name="tab-set--11" type="radio"><label class="tab-label" for="tab-set--11-input--2">英文</label><div class="tab-content docutils container">
<p>One additional loader strategy worth mentioning is <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a>.
This option is used to completely block an application from having the
<a class="reference internal" href="../glossary.html#term-N-plus-one"><span class="xref std std-term">N plus one</span></a> problem at all by causing what would normally be a lazy
load to raise an error instead.   It has two variants that are controlled via
the <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only" title="sqlalchemy.orm.raiseload"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">raiseload.sql_only</span></code></a> option to block either lazy loads
that require SQL, versus all “load” operations including those which
only need to consult the current <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>.</p>
<p>One way to use <a class="reference internal" href="../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload" title="sqlalchemy.orm.raiseload"><code class="xref py py-func docutils literal notranslate"><span class="pre">raiseload()</span></code></a> is to configure it on
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> itself, by setting <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy" title="sqlalchemy.orm.relationship"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">relationship.lazy</span></code></a>
to the value <code class="docutils literal notranslate"><span class="pre">&quot;raise_on_sql&quot;</span></code>, so that for a particular mapping, a certain
relationship will never try to emit SQL:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapped</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sqlalchemy.orm</span><span class="w"> </span><span class="kn">import</span> <span class="n">relationship</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;user_account&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     addresses: Mapped[List[&quot;Address&quot;]] = relationship(</span>
<span class="go">...         back_populates=&quot;user&quot;, lazy=&quot;raise_on_sql&quot;</span>
<span class="go">...     )</span>


<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="go">...     __tablename__ = &quot;address&quot;</span>
<span class="go">...     id: Mapped[int] = mapped_column(primary_key=True)</span>
<span class="go">...     user_id: Mapped[int] = mapped_column(ForeignKey(&quot;user_account.id&quot;))</span>
<span class="go">...     user: Mapped[&quot;User&quot;] = relationship(back_populates=&quot;addresses&quot;, lazy=&quot;raise_on_sql&quot;)</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>Using such a mapping, the application is blocked from lazy loading,
indicating that a particular query would need to specify a loader strategy:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="p">))</span><span class="o">.</span><span class="n">scalars</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
</div><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span><span class="o">.</span><span class="n">addresses</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">sqlalchemy.exc.InvalidRequestError: &#39;User.addresses&#39; is not available due to lazy=&#39;raise_on_sql&#39;</span></pre></div>
</div>
<p>The exception would indicate that this collection should be loaded up front
instead:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u1</span> <span class="o">=</span> <span class="p">(</span>
<span class="go">...     session.execute(select(User).options(selectinload(User.addresses)))</span>
<span class="go">...     .scalars()</span>
<span class="go">...     .first()</span>
<span class="go">... )</span>
<div class='show_sql'><span class="k">SELECT</span><span class="w"> </span><span class="n">user_account</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">user_account</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">()</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_user_id</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">address_id</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">address</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">address</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">)</span>
<span class="p">[...]</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span>
</div></pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">lazy=&quot;raise_on_sql&quot;</span></code> option tries to be smart about many-to-one
relationships as well; above, if the <code class="docutils literal notranslate"><span class="pre">Address.user</span></code> attribute of an
<code class="docutils literal notranslate"><span class="pre">Address</span></code> object were not loaded, but that <code class="docutils literal notranslate"><span class="pre">User</span></code> object were locally
present in the same <a class="reference internal" href="../orm/session_api.html#sqlalchemy.orm.Session" title="sqlalchemy.orm.Session"><code class="xref py py-class docutils literal notranslate"><span class="pre">Session</span></code></a>, the “raiseload” strategy would not
raise an error.</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p><a class="reference internal" href="../orm/queryguide/relationships.html#prevent-lazy-with-raiseload"><span class="std std-ref">使用 raiseload 防止不必要的延迟加载</span></a> - in <a class="reference internal" href="../orm/queryguide/relationships.html#loading-toplevel"><span class="std std-ref">关系加载技术</span></a></p>
</div>
</div>
</div>
</section>
</section>
</section>
<aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>Next Tutorial Section: <a class="reference internal" href="further_reading.html"><span class="doc">进一步阅读</span></a></p>
</aside>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="further_reading.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">进一步阅读</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="orm_data_manipulation.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">使用 ORM 进行数据操作</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                <a href="../copyright.html">Copyright</a> &#169; 2007-2025, the SQLAlchemy authors and contributors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on 04/05/2025 04:00:26</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">使用 ORM 相关对象</a><ul>
<li><a class="reference internal" href="#id1">持久化和加载关系</a><ul>
<li><a class="reference internal" href="#tutorial-orm-cascades">将对象级联到会话中</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-loading-relationships">加载关系</a></li>
<li><a class="reference internal" href="#tutorial-select-relationships">在查询中使用关系</a><ul>
<li><a class="reference internal" href="#tutorial-joining-relationships">使用关系进行连接</a></li>
<li><a class="reference internal" href="#where">关系 WHERE 运算符</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tutorial-orm-loader-strategies">加载器策略</a><ul>
<li><a class="reference internal" href="#id7">选择加载</a></li>
<li><a class="reference internal" href="#id8">连接加载</a></li>
<li><a class="reference internal" href="#tutorial-orm-loader-strategies-contains-eager">显式连接 + 预加载</a></li>
<li><a class="reference internal" href="#id10">提升加载</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=2d0eb83f"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/tabs.js?v=3ee01567"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=2f3e6152"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    </body>
</html>